// Try Over3 3 Q4
export const problem = {
  "section": "03_method",
  "id": "03_try_over3_3_q4",
  "title": "Try Over3 3 Q4",
  "title_en": "Try Over3 3 Q4",
  "description": "高度なメタプログラミング技術の問題。method_missing、プロキシオブジェクト、const_missing、DSLの実装などを学びます。 (Q4)",
  "description_en": "Advanced metaprogramming techniques problems. Learn about method_missing, proxy objects, const_missing, DSL implementation, etc. (Q4)",
  "detailedDescription": "以下のように実行できる TryOver3::A4 クラスを作成してください。\n\n```\nTryOver3::A4.runners = [:Hoge]\nTryOver3::A4::Hoge.run\n=> \"run Hoge\"\n```\n\nこのとき、TryOver3::A4::Hogeという定数は定義されません。\n\nTryOver3::TaskHelper という include すると task というクラスマクロが与えられる以下のようなモジュールがあります。\nTryOver3::TaskHelper は include することで以下のような使い方ができます。\n\n```\nirb(main):001:0> TryOver3::A3Task::Foo.run\nstart 2020-01-07 18:03:10 +0900\nfinish 2020-01-07 18:03:10 +0900\n=> \"foo\"\n```\n\n今回 TryOver3::TaskHelper では TryOver3::A5Task::Foo のように Foo クラスを作らず\nTryOver3::A5Task.foo のようにクラスメソッドとして task で定義された名前のクラスメソッドでブロックを実行するように変更したいです。\n現在 TryOver3::TaskHelper のユーザには TryOver3::A5Task::Foo.run のように生成されたクラスを使って実行しているユーザが存在します。\n今回変更を加えても、その人たちにはこれまで通り生成されたクラスのrunメソッドでタスクを実行できるようにしておいて、warning だけだしておくようにしたいです。\nTryOver3::TaskHelper を修正してそれを実現してください。 なお、その際、クラスは実行されない限り生成されないものとします。\n\n変更後想定する使い方\nメソッドを使ったケース\n\n```\nirb(main):001:0> TryOver3::A5Task.foo\nstart 2020-01-07 18:03:10 +0900\nfinish 2020-01-07 18:03:10 +0900\n=> \"foo\"\n```\n\nクラスのrunメソッドを使ったケース\n\n```\nirb(main):001:0> TryOver3::A5Task::Foo.run\nWarning: TryOver3::A5Task::Foo.run is deprecated\nstart 2020-01-07 18:03:10 +0900\nfinish 2020-01-07 18:03:10 +0900\n=> \"foo\"\n```",
  "detailedDescription_en": "Please create a TryOver3::A4 class that can be executed as follows.\n\n```\nTryOver3::A4.runners = [:Hoge]\nTryOver3::A4::Hoge.run\n=> \"run Hoge\"\n```\n\nAt this time, the constant TryOver3::A4::Hoge is not defined.\n\nThere is a module called TryOver3::TaskHelper that provides a class macro called task when included.\nTryOver3::TaskHelper can be used as follows when included:\n\n```\nirb(main):001:0> TryOver3::A3Task::Foo.run\nstart 2020-01-07 18:03:10 +0900\nfinish 2020-01-07 18:03:10 +0900\n=> \"foo\"\n```\n\nThis time, with TryOver3::TaskHelper, instead of creating a Foo class like TryOver3::A5Task::Foo,\nwe want to change it to execute the block with a class method of the name defined by task, like TryOver3::A5Task.foo.\nCurrently, some users of TryOver3::TaskHelper are executing using the generated class like TryOver3::A5Task::Foo.run.\nEven with this change, we want to allow them to continue executing tasks with the run method of the generated class as before,\nand just output a warning.\nPlease modify TryOver3::TaskHelper to achieve this. Note that classes should not be generated unless they are executed.\n\nExpected usage after change\nCase using method\n\n```\nirb(main):001:0> TryOver3::A5Task.foo\nstart 2020-01-07 18:03:10 +0900\nfinish 2020-01-07 18:03:10 +0900\n=> \"foo\"\n```\n\nCase using class run method\n\n```\nirb(main):001:0> TryOver3::A5Task::Foo.run\nWarning: TryOver3::A5Task::Foo.run is deprecated\nstart 2020-01-07 18:03:10 +0900\nfinish 2020-01-07 18:03:10 +0900\n=> \"foo\"\n```",
  "problemCode": "TryOver3 = Module.new\n\n# Q5. チャレンジ問題！ 挑戦する方はテストの skip を外して挑戦してみてください。\nmodule TryOver3::TaskHelper\n  def self.included(klass)\n    klass.define_singleton_method :task do |name, &task_block|\n      new_klass = Class.new do\n        define_singleton_method :run do\n          puts \"start #{Time.now}\"\n          block_return = task_block.call\n          puts \"finish #{Time.now}\"\n          block_return\n        end\n      end\n      new_klass_name = name.to_s.split('_').map do |w|\n        w[0] = w[0].upcase\n        w\n      end.join\n      const_set(new_klass_name, new_klass)\n    end\n  end\nend\n\nclass TryOver3::A5Task\n  include TryOver3::TaskHelper\n\n  task :foo do\n    'foo'\n  end\nend\n",
  "answerCode": "TryOver3 = Module.new\n\n# Q4. 問題の解説\n#\n# const_missingを利用して、runners=で定義した定数を参照したときにrunメソッドを持つオブジェクトを返すことで\n# 仕様を満たしています。回答例ではObject.newでオブジェクトを生成しましたが、runメソッドを持つオブジェクトであれば\n# どんなクラスのインスタンスでもOKです。\n#\nclass TryOver3::A4\n  def self.const_missing(const)\n    if @consts.include?(const)\n      obj = Object.new\n      obj.define_singleton_method(:run) { \"run #{const}\" }\n      obj\n    else\n      super\n    end\n  end\n\n  def self.runners=(consts)\n    @consts = consts\n  end\nend\n",
  "testCode": "require 'minitest'\nrequire 'minitest/mock'\n\nclass TestTryOver03Q1 < Minitest::Test\n  def test_q4_call_class\n    TryOver3::A4.runners = [:Hoge]\n    assert_equal 'run Hoge', TryOver3::A4::Hoge.run\n  end\n\n  def test_q4_raise_error_when_called_not_runner_class\n    TryOver3::A4.runners = [:Hoge]\n    assert_raises(NameError) { TryOver3::A4::Foo }\n  end\n\n  def test_q4_not_exists_runner_class\n    TryOver3::A4.runners = [:Hoge]\n    refute_includes(TryOver3::A4.constants, :Hoge)\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend\n",
  "answerExplanation": "",
  "answerExplanation_en": ""
};

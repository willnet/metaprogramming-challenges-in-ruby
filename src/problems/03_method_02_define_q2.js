// Define Q2
export const problem = {
  "section": "03_method",
  "id": "02_define_q2",
  "title": "Define Q2",
  "title_en": "Define Q2",
  "description": "動的にメソッドを定義し、インスタンスごとに異なるメソッドを持つA2クラスを実装します。",
  "description_en": "Implement A2 class that dynamically defines methods and has different methods per instance.",
  "detailedDescription": "次の動作をする A2 class を実装する\n\n- 1. \"SmartHR Dev Team\"と返すdev_teamメソッドが存在すること\n- 2. initializeに渡した配列に含まれる値に対して、\"hoge_\" をprefixを付与したメソッドが存在すること\n- 2で定義するメソッドは下記とする\n  - 受け取った引数の回数分、メソッド名を繰り返した文字列を返すこと\n  - 引数がnilの場合は、dev_teamメソッドを呼ぶこと\n- また、2で定義するメソッドは以下を満たすものとする\n  - メソッドが定義されるのは同時に生成されるオブジェクトのみで、別のA2インスタンスには（同じ値を含む配列を生成時に渡さない限り）定義されない",
  "detailedDescription_en": "Implement A2 class that behaves as follows\n\n- 1. A dev_team method that returns \"SmartHR Dev Team\" exists\n- 2. Methods with \"hoge_\" prefix are dynamically created for values passed to initialize\n- Methods defined in step 2 should:\n  - Return a string that repeats the method name the number of times specified by the argument\n  - Call the dev_team method when the argument is nil\n- Additionally, methods defined in step 2 should meet the following requirements:\n  - Methods are defined only for the specific instance created, not for other A2 instances (unless the same array is passed during creation)",
  "problemCode": "# Q2.\n# 次の動作をする A2 class を実装する\n# - 1. \"SmartHR Dev Team\"と返すdev_teamメソッドが存在すること\n# - 2. initializeに渡した配列に含まれる値に対して、\"hoge_\" をprefixを付与したメソッドが存在すること\n# - 2で定義するメソッドは下記とする\n#   - 受け取った引数の回数分、メソッド名を繰り返した文字列を返すこと\n#   - 引数がnilの場合は、dev_teamメソッドを呼ぶこと\n# - また、2で定義するメソッドは以下を満たすものとする\n#   - メソッドが定義されるのは同時に生成されるオブジェクトのみで、別のA2インスタンスには（同じ値を含む配列を生成時に渡さない限り）定義されない\n\nclass A2\n  def initialize(values)\n    # ここにコードを書く\n  end\n\n  def dev_team\n    # ここにコードを書く\n  end\nend",
  "answerExplanation": "",
  "answerExplanation_en": "",
  "answerCode": "# Q2.\n# 次の動作をする A2 class を実装する\n# - 1. \"SmartHR Dev Team\"と返すdev_teamメソッドが存在すること\n# - 2. initializeに渡した配列に含まれる値に対して、\"hoge_\" をprefixを付与したメソッドが存在すること\n# - 2で定義するメソッドは下記とする\n#   - 受け取った引数の回数分、メソッド名を繰り返した文字列を返すこと\n#   - 引数がnilの場合は、dev_teamメソッドを呼ぶこと\n# - また、2で定義するメソッドは以下を満たすものとする\n#   - メソッドが定義されるのは同時に生成されるオブジェクトのみで、別のA2インスタンスには（同じ値を含む配列を生成時に渡さない限り）定義されない\n\nclass A2\n  def initialize(ary)\n    ary.each do |name|\n      method_name = \"hoge_#{name}\"\n\n      define_singleton_method method_name do |times|\n        if times.nil?\n          dev_team\n        else\n          method_name * times\n        end\n      end\n    end\n  end\n\n  def dev_team\n    'SmartHR Dev Team'\n  end\nend",
  "testCode": "require 'minitest'\nrequire 'securerandom'\n\nclass TestDefine < Minitest::Test\n  def test_answer_a2\n    instance = A2.new([\"hoge\", \"fuga\"])\n\n    assert_equal true, instance.methods.include?(:dev_team)\n    assert_equal \"SmartHR Dev Team\", instance.hoge_hoge(nil)\n    assert_equal \"hoge_hogehoge_hoge\", instance.hoge_hoge(2)\n    assert_equal \"hoge_fugahoge_fugahoge_fuga\", instance.hoge_fuga(3)\n\n    another_instance = A2.new([])\n    assert_equal false, another_instance.methods.include?(:hoge_hoge)\n    assert_equal false, another_instance.methods.include?(:hoge_fuga)\n  end\n\n  def test_answer_a2_number\n    instance = A2.new([1, 2])\n\n    assert_equal true, instance.methods.include?(:dev_team)\n    assert_equal \"SmartHR Dev Team\", instance.hoge_1(nil)\n    assert_equal \"hoge_1hoge_1\", instance.hoge_1(2)\n    assert_equal \"hoge_2hoge_2hoge_2\", instance.hoge_2(3)\n\n    another_instance = A2.new([])\n    assert_equal false, another_instance.methods.include?(:hoge_1)\n    assert_equal false, another_instance.methods.include?(:hoge_2)\n  end\n\n  def test_answer_a2_random_name\n    value_one = SecureRandom.hex\n    value_two = SecureRandom.hex\n\n    instance = A2.new([value_one, value_two])\n    assert_equal true, instance.methods.include?(:dev_team)\n    assert_equal \"SmartHR Dev Team\", instance.send(\"hoge_#{value_one}\".to_sym, nil)\n    assert_equal \"hoge_#{value_one}hoge_#{value_one}\", instance.send(\"hoge_#{value_one}\".to_sym, 2)\n    assert_equal \"hoge_#{value_two}hoge_#{value_two}hoge_#{value_two}\", instance.send(\"hoge_#{value_two}\".to_sym, 3)\n\n    another_instance = A2.new([])\n    assert_equal false, another_instance.methods.include?(\"hoge_#{value_one}\".to_sym)\n    assert_equal false, another_instance.methods.include?(\"hoge_#{value_two}\".to_sym)\n  end\n\n  def test_answer_a2_called_dev_team\n    instance = A2.new([1])\n\n    @called_dev_team = false\n    trace = TracePoint.new(:call) do |tp|\n      @called_dev_team = tp.event == :call && tp.method_id == :dev_team unless @called_dev_team\n    end\n    trace.enable\n    instance.hoge_1(nil)\n    trace.disable\n\n    assert_equal true, @called_dev_team\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
};

// Try Over3 3 Q1
export const problem = {
  "section": "03_method",
  "id": "03_try_over3_3_q1",
  "title": "Try Over3 3 Q1",
  "title_en": "Try Over3 3 Q1",
  "description": "高度なメタプログラミング技術の問題。method_missing、プロキシオブジェクト、const_missing、DSLの実装などを学びます。 (Q1)",
  "description_en": "Advanced metaprogramming techniques quiz. Learn about method_missing, proxy objects, const_missing, DSL implementation, etc. (Q1)",
  "detailedDescription": "以下要件を満たすクラス TryOver3::A1 を作成してください。\n\n- run_test というインスタンスメソッドを持ち、それはnilを返す\n- `test_` から始まるインスタンスメソッドが実行された場合、このクラスは `run_test` メソッドを実行する\n  - `test_` メソッドがこのクラスに実装されていなくても `test_` から始まるメッセージに応答することができる\n  - TryOver3::A1 には `test_` から始まるインスタンスメソッドが定義されていない",
  "detailedDescription_en": "Please create a class TryOver3::A1 that meets the following requirements.\n- It has an instance method called run_test that returns nil\n- When an instance method starting with `test_` is executed, this class executes the `run_test` method\n  - Even if the `test_` method is not implemented in this class, it can respond to messages starting with `test_`\n  - TryOver3::A1 does not have any instance methods defined that start with `test_`",
  "problemCode": "TryOver3 = Module.new\n",
  "answerCode": "TryOver3 = Module.new\n\nclass TryOver3::A1\n  def run_test; end\n\n  def method_missing(name, *)\n    if name.to_s.start_with?('test_')\n      run_test\n    else\n      super\n    end\n  end\n\n  def respond_to_missing?(name, _)\n    name.to_s.start_with?('test_')\n  end\nend\n",
  "testCode": "require 'minitest'\nrequire 'minitest/mock'\n\nclass TestTryOver03Q1 < Minitest::Test\n  def test_q1_called_run_test\n    a1 = TryOver3::A1.new\n    mock = Minitest::Mock.new\n    a1.stub(:run_test, mock) do\n      a1.test_hoge\n    end\n    assert mock.verify\n  end\n\n  def test_q1_run_raise_error\n    assert_raises(NoMethodError) { TryOver3::A1.new.testhoge }\n  end\n\n  def test_q1_methods_not_included_test\n    assert_equal false, TryOver3::A1.instance_methods(false).any? { |method_name| method_name.to_s.start_with?('test_') }\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend\n",
  "answerExplanation": "この問題は、Rubyの`method_missing`を使った「ゴーストメソッド」の実装を学ぶものです。\n\nゴーストメソッドとは：\n- 実際には定義されていないが、呼び出すことができるメソッド\n- `method_missing`で動的に処理される\n\n実装のポイント：\n1. `method_missing`メソッドで、呼び出されたメソッド名が`test_`で始まるかチェック\n2. 該当する場合は`run_test`を実行、そうでなければ`super`で親クラスに委譲\n3. `respond_to_missing?`も合わせて定義することで、`respond_to?`が正しく動作する\n\n`respond_to_missing?`について：\n- `method_missing`を定義する際は、セットで定義するのがベストプラクティス\n- これにより、`obj.respond_to?(:test_foo)`が`true`を返すようになる\n- メソッドの存在確認が正しく動作し、より一貫性のある振る舞いを実現",
  "answerExplanation_en": "This quiz teaches implementing \"ghost methods\" using Ruby's `method_missing`.\n\nWhat are ghost methods:\n- Methods that aren't actually defined but can be called\n- Dynamically handled by `method_missing`\n\nKey implementation points:\n1. In `method_missing`, check if the called method name starts with `test_`\n2. If it does, execute `run_test`; otherwise, delegate to the parent class with `super`\n3. Also define `respond_to_missing?` to make `respond_to?` work correctly\n\nAbout `respond_to_missing?`:\n- It's best practice to define it alongside `method_missing`\n- This makes `obj.respond_to?(:test_foo)` return `true`\n- Ensures method existence checks work correctly, achieving more consistent behavior"
};

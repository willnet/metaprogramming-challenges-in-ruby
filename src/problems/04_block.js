export const blockProblems = [
  {
    "section": "04_block",
    "id": "01_block_first_step",
    "title": "Block First Step",
    "description": "Rubyのブロックについての基本的な問題。ブロックの受け渡しや実行、クロージャについて学びます。",
    "problemCode": "# Q1.\n# MyMathクラスに、ブロックを実行した結果(数値)を2倍にして返すtwo_timesインスタンスメソッドを定義しましょう\n#    実行例: MyMath.new.two_times { 2 } #=> 4\n\nclass MyMath\nend\n\n# Q2.\n# AcceptBlockクラスにcallクラスメソッドが予め定義されており、このメソッドがブロックをとるとします。\n# 実行例: AcceptBlock.call { 2 }\n# このメソッドを、下で用意されているMY_LAMBDAをブロック引数として渡して実行してみてください。\n# AcceptBlockクラスは問題側で用意している(テスト中に実装している)ため実装の必要はありません。\n\nMY_LAMBDA = -> { 3 }\n\n# Q3.\n# MyBlockクラスにblock_to_procインスタンスメソッドを定義しましょう。block_to_procインスタンスメソッドはブロックを受け取り、\n# そのブロックをProcオブジェクトにしたものを返します\n\nclass MyBlock\nend\n\n# Q4.\n# MyClosureクラスにincrementインスタンスメソッドを定義しましょう。このincrementメソッドは次のように数値を1ずつインクリメントして返します\n# my = MyClosure.new\n# my.increment #=> 1\n# my.increment #=> 2\n# my.increment #=> 3\n# それに加えて、複数のインスタンスでカウンターを共有しているという特性があります。\n# my1 = MyClosure.new\n# my2 = MyClosure.new\n# my1.increment #=> 1\n# my2.increment #=> 2\n# my1.increment #=> 3\n# さらなる制限として、カウンターとして利用する変数はローカル変数を利用してください(これはテストにはないですが頑張ってローカル変数でテストを通るようにしてみてください)\n\nclass MyClosure\nend",
    "answerCode": "# Q1. 問題の解説\n#\n# yieldもしくはcallメソッドを使うメソッド実装の練習です。Railsでアプリケーションを書いているとそれほどブロックを取る\n# メソッドを書く機会はないのですが、素振りをしておいていざというときに使えるようにしておくと役に立つ時が来るかもしれません\nclass MyMath\n  def two_times\n    yield * 2\n  end\nend\n\n# Q2. 問題の解説\n#\n# Procオブジェクトをブロック引数として渡す練習です。実引数を渡すところで`&`を使うと、Procからブロックへの変換ができます。\nMY_LAMBDA = -> { 3 }\nAcceptBlock.call(&MY_LAMBDA)\n\n# Q3. 問題の解説\n#\n# Q2と反対に、ブロックからProcオブジェクトの変換をする練習です。仮引数で&を使うとブロックからProcオブジェクトへの変換ができます。\nclass MyBlock\n  def block_to_proc(&block)\n    block\n  end\nend\n\n\n# Q4. 問題の解説\n#\n# クロージャを実装してみる練習です。ブロックを利用するとスコープゲートなしで束縛を利用できるのでしたね。メソッド定義をdefではなく\n# define_method にすることで外側のローカル変数への参照を持ち続けることができます。\nclass MyClosure\n  count = 0\n\n  define_method :increment do\n    count += 1\n  end\nend",
    "testCode": "require 'minitest'\n\nclass AcceptBlock\n  class << self\n    attr_accessor :result\n  end\n\n  def self.call(&block)\n    @result = block == MY_LAMBDA\n  end\nend\n\nclass TestBlockFirstStep < Minitest::Test\n  def test_my_math\n    assert_equal 4, MyMath.new.two_times { 2 }\n  end\n\n  def test_accept_block\n    assert AcceptBlock.result\n  end\n\n  def test_my_block\n    assert_equal(MY_LAMBDA, MyBlock.new.block_to_proc(&MY_LAMBDA))\n  end\n\n  def test_my_closure\n    m1 = MyClosure.new\n    m2 = MyClosure.new\n    assert_equal(1, m1.increment)\n    assert_equal(2, m2.increment)\n    assert_equal(3, m1.increment)\n    MyClosure\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "04_block",
    "id": "02_evil_mailbox",
    "title": "Evil Mailbox",
    "description": "複雑なブロック処理とクロージャキャプチャを使ったメールボックスの実装問題。認証機能や秘密文字列の処理を学びます。",
    "problemCode": "# 次の仕様を満たすクラス、EvilMailboxを作成してください\n#\n# 基本機能\n# 1. EvilMailboxは、コンストラクタで一つのオブジェクトを受け取る（このオブジェクトは、メールの送受信機能が実装されているが、それが何なのかは気にする必要はない）\n# 2. EvilMailboxは、メールを送るメソッド `send_mail` を持ち、引数として宛先の文字列、本文の文字列を受け取る。結果の如何に関わらず、メソッドはnilをかえす。\n# 3. send_mailメソッドは、内部でメールを送るために、コンストラクタで受け取ったオブジェクトのsend_mailメソッドを呼び出す。このときのシグネチャは同じである。また、このメソッドはメールの送信が成功したか失敗したかをbool値で返す。\n# 4. EvilMailboxは、メールを受信するメソッド `receive_mail` を持つ\n# 5. receive_mailメソッドは、メールを受信するためにコンストラクタで受け取ったオブジェクトのreceive_mailメソッドを呼び出す。このオブジェクトのreceive_mailは、送信者と本文の2つの要素をもつ配列を返す。\n# 6. receive_mailメソッドは、受け取ったメールを送信者と本文の2つの要素をもつ配列として返す\n#\n# 応用機能\n# 1. send_mailメソッドは、ブロックを受けとることができる。ブロックは、送信の成功/失敗の結果をBool値で引数に受け取ることができる\n# 2. コンストラクタは、第2引数として文字列を受け取ることができる（デフォルトはnilである）\n# 3. コンストラクタが第2引数として文字列を受け取った時、第1引数のオブジェクトはその文字列を引数にしてauthメソッドを呼び出す\n# 4. 第2引数の文字列は、秘密の文字列のため、EvilMailboxのオブジェクトの中でいかなる形でも保存してはいけない\n#\n# 邪悪な機能\n# 1. send_mailメソッドは、もしも\"コンストラクタで受け取ったオブジェクトがauthメソッドを呼んだ\"とき、勝手にその認証に使った文字列を、送信するtextの末尾に付け加える\n# 2. つまり、コンストラクタが第2引数に文字列を受け取った時、その文字列はオブジェクト内に保存されないが、send_mailを呼び出したときにこっそりと勝手に送信される",
    "answerCode": "# 問題の解説\n#\n# 仕様の「邪悪な機能」をクロージャを使って実装することに気付けるかどうかを問う問題です。\n# initializeメソッドの中でdefine_singleton_methodを利用してsend_mailメソッドを定義することで、\n# initializeメソッドのローカル変数として第2引数を扱います。こうすることで、\n# send_mailメソッドの中でしか参照できない変数ができあがります。\n\nclass EvilMailbox\n  def initialize(obj, str = nil)\n    @obj = obj\n    @obj.auth(str) if str\n\n    define_singleton_method(:send_mail) do |to, body, &block|\n      result = obj.send_mail(to, body + str.to_s)\n      block.call(result) if block\n      nil\n    end\n  end\n\n  def receive_mail\n    obj.receive_mail\n  end\n\n  private\n\n  attr_reader :obj\nend",
    "testCode": "require 'minitest'\n\nclass TestEvilMailbox < Minitest::Test\n  def evil_mailbox(&block)\n    mock = Minitest::Mock.new\n    mock.instance_eval(&block) if block_given?\n    [EvilMailbox.new(mock), mock]\n  end\n\n  def test_send_mail\n    mb, mock = evil_mailbox do\n      expect :send_mail, true, [\"ppyd\", \"hello\"]\n    end\n    mb.send_mail(\"ppyd\", \"hello\")\n    mock.verify\n  end\n\n  def test_send_mail_returns_nil\n    mb, _ = evil_mailbox do\n      expect :send_mail, true, [\"ppyd\", \"hello\"]\n    end\n    assert_nil mb.send_mail(\"ppyd\", \"hello\")\n  end\n\n  def test_receive_mail\n    mb, mock = evil_mailbox do\n      expect :receive_mail, [\"kino\", \"Yo\"]\n    end\n    f, t = mb.receive_mail\n    mock.verify\n    assert_equal \"kino\", f\n    assert_equal \"Yo\", t\n  end\n\n  def test_send_mail_exec_block_with_result_true\n    mb, _ = evil_mailbox do\n      expect :send_mail, true, [\"ppyd\", \"hello\"]\n    end\n    ret = nil\n    mb.send_mail(\"ppyd\", \"hello\") do |res|\n      ret = res\n    end\n    assert_equal true, ret\n  end\n\n  def test_send_mail_exec_block_with_result_false\n    mb, _ = evil_mailbox do\n      expect :send_mail, false, [\"ppyd\", \"hello\"]\n    end\n    ret = nil\n    mb.send_mail(\"ppyd\", \"hello\") do |res|\n      ret = res\n    end\n    assert_equal false, ret\n  end\n\n  def test_mail_object_auth\n    secret_string = SecureRandom.hex\n    mock = Minitest::Mock.new\n    mock.expect :auth, true, [String]\n    EvilMailbox.new(mock, secret_string)\n    mock.verify\n  end\n\n  def test_send_mail_with_secret_string\n    secret_string = SecureRandom.hex\n    mock = Minitest::Mock.new\n    mock.expect :auth, true, [String]\n    mock.expect :send_mail, true, [\"ppyd\", \"hello#{secret_string}\"]\n    mb = EvilMailbox.new(mock, secret_string)\n\n    mb.send_mail(\"ppyd\", \"hello\")\n    mock.verify\n  end\n\n  def test_no_secret_string_in_object\n    secret_string = SecureRandom.hex\n    mock = Minitest::Mock.new\n    mock.expect :auth, true, [String]\n    mb = EvilMailbox.new(mock, secret_string)\n\n    mock.verify\n    mb.class.send(:class_variables).each do |cv|\n      assert_equal false, secret_string == mb.class.get_class_variable(cv)\n    end\n    mb.send(:instance_variables).each do |iv|\n      assert_equal false, secret_string == mb.instance_variable_get(iv)\n    end\n  end\n\n  def evil_mailbox_with_secret_string(secret_string, &block)\n    mock = Minitest::Mock.new\n    mock.instance_eval(&block) if block_given?\n    [EvilMailbox.new(mock, secret_string), mock]\n  end\n\n  def test_send_mail_exec_block_with_result_true_and_secret_string\n    secret_string = SecureRandom.hex\n    mb, mock = evil_mailbox_with_secret_string(secret_string) do\n      expect :auth, true, [String]\n      expect :send_mail, true, [\"ppyd\", \"hello#{secret_string}\"]\n    end\n\n    ret = nil\n    mb.send_mail(\"ppyd\", \"hello\") do |res|\n      ret = res\n    end\n    mock.verify\n    assert_equal true, ret\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "04_block",
    "id": "03_simple_bot",
    "title": "Simple Bot",
    "description": "ブロックを使ったDSLの作成問題。ボット作成のためのDSLを実装して、respond、setting、settingsメソッドを学びます。",
    "problemCode": "# 次の仕様を満たすSimpleBotクラスとDSLを作成してください\n#\n# # これは、作成するSimpleBotクラスの利用イメージです\n# class Bot < SimpleBot\n#   setting :name, 'bot'\n#   respond 'keyword' do\n#     \"response #{settings.name}\"\n#   end\n# end\n#\n# Bot.new.ask('keyword') #=> 'respond bot'\n#\n# 1. SimpleBotクラスを継承したクラスは、クラスメソッドrespond, setting, settingsを持ちます\n#     1. settingsメソッドは、任意のオブジェクトを返します\n#     2. settingsメソッドは、後述するクラスメソッドsettingによって渡された第一引数と同名のメソッド呼び出しに応答します\n# 2. SimpleBotクラスのサブクラスのインスタンスは、インスタンスメソッドaskを持ちます\n#     1. askは、一つの引数をとります\n#     2. askに渡されたオブジェクトが、後述するrespondメソッドで設定したオブジェクトと一致する場合、インスタンスは任意の返り値を持ちます\n#     3. 2のケースに当てはまらない場合、askメソッドの戻り値はnilです\n# 3. クラスメソッドrespondは、keywordとブロックを引数に取ります\n#     1. respondメソッドの第1引数keywordと同じ文字列が、インスタンスメソッドaskに渡された時、第2引数に渡したブロックが実行され、その結果が返されます\n# 4. クラスメソッドsettingは、引数を2つ取り、1つ目がキー名、2つ目が設定する値です\n#     1. settingメソッドに渡された値は、クラスメソッド `settings` から返されるオブジェクトに、メソッド名としてアクセスすることで取り出すことができます\n#     2. e.g. クラス内で `setting :name, 'bot'` と実行した場合は、respondメソッドに渡されるブロックのスコープ内で `settings.name` の戻り値は `bot` の文字列になります",
    "answerCode": "# 問題の解説\n#\n# respondクラスメソッドで定義したブロックを、askインスタンスメソッドからどうやって参照するか、というのが\n# この問題の難所です。クラスメソッドで定義したインスタンス変数はクラスインスタンス変数としてクラスそのものに\n# 紐づくインスタンス変数になるので、インスタンスメソッドから参照するには、回答例のように\n# `self.class.instance_variable_get(インスタンス変数名)`のようにします。\n# クラス変数を利用するとクラスメソッド、インスタンスメソッドどちらからでも`@@respond`のようにアクセスできるので\n# 一見便利ですが、意図せず別のクラスとクラス変数が共有される可能性があるため、推奨しません。\n#\n# SimpleBotとそのサブクラスで利用イメージのように定義されたブロックは、settingsクラスメソッドにアクセスできます。\n# settingsクラスメソッドは、settingクラスメソッドで登録したキーと値をそれぞれメソッド名とその返り値に持つオブジェクトを返すと\n# 仕様を満たせます。メソッドが定義できればどんなオブジェクトを返しても仕様を満たせるため、この回答例では\n# 特異メソッドを定義したObjectインスタンスを返しています。必ずしもObjectインスタンスである必要はありません。\n#\nclass SimpleBot\n  class << self\n    def respond(keyword, &block)\n      @respond ||= {}\n      @respond[keyword] = block\n    end\n\n    def setting(key, value)\n      @settings ||= {}\n      @settings[key] = value\n    end\n\n    def settings\n      obj = Object.new\n\n      @settings&.each do |key, value|\n        obj.define_singleton_method(key) do\n          value\n        end\n      end\n      obj\n    end\n  end\n\n  def ask(keyword)\n    block = self.class.instance_variable_get(:@respond)[keyword]\n    block.call if block\n  end\nend",
    "testCode": "require 'minitest'\n\nclass TestSimpleBot < Minitest::Test\n  def bot_for_test(&block)\n    Class.new(SimpleBot, &block)\n  end\n\n  def test_response\n    klass = bot_for_test do\n      respond 'hello' do\n        'Yo'\n      end\n    end\n\n    assert_equal 'Yo', klass.new.ask('hello')\n  end\n\n  def test_no_response\n    klass = bot_for_test do\n      respond 'yo' do\n        'yo'\n      end\n    end\n\n    assert_nil klass.new.ask(\"hello\")\n  end\n\n  def test_global_setting\n    klass = bot_for_test do\n      setting :name, 'bot'\n      respond 'what is your name?' do\n        \"i'm #{settings.name}\"\n      end\n    end\n\n    assert_equal \"i'm bot\", klass.new.ask(\"what is your name?\")\n  end\n\n  def test_global_setting_random\n    code = SecureRandom.hex\n\n    klass = bot_for_test do\n      setting :code, code\n      respond 'tell me your code' do\n        \"code is #{settings.code}\"\n      end\n    end\n\n    assert_equal \"code is #{code}\", klass.new.ask('tell me your code')\n  end\n\n  def test_global_setting_multiple_call\n    klass = bot_for_test do\n      setting :name, 'bot'\n      setting :age, 10\n      respond 'what is your name?' do\n        \"i'm #{settings.name}\"\n      end\n      respond 'how old are you?' do\n        \"i'm #{settings.age} years old\"\n      end\n    end\n\n    assert_equal \"i'm bot\", klass.new.ask(\"what is your name?\")\n    assert_equal \"i'm 10 years old\", klass.new.ask(\"how old are you?\")\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  }
];
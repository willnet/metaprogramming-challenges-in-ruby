// Simple Model
export const problem = {
  "section": "06_codes_generate_codes",
  "id": "01_simple_model",
  "title": "Simple Model",
  "description": "ActiveRecordライクなモデルの実装問題。変更追跡機能付きのattr_accessorとrestoreメソッドを学びます。",
  "problemCode": "# 次の仕様を満たす、SimpleModelモジュールを作成してください\n#\n# 1. include されたクラスがattr_accessorを使用すると、以下の追加動作を行う\n#   1. 作成したアクセサのreaderメソッドは、通常通りの動作を行う\n#   2. 作成したアクセサのwriterメソッドは、通常に加え以下の動作を行う\n#     1. 何らかの方法で、writerメソッドを利用した値の書き込み履歴を記憶する\n#     2. いずれかのwriterメソッド経由で更新をした履歴がある場合、 `true` を返すメソッド `changed?` を作成する\n#     3. 個別のwriterメソッド経由で更新した履歴を取得できるメソッド、 `ATTR_changed?` を作成する\n#       1. 例として、`attr_accessor :name, :desc`　とした時、このオブジェクトに対して `obj.name = 'hoge'` という操作を行ったとする\n#       2. `obj.name_changed?` は `true` を返すが、 `obj.desc_changed?` は `false` を返す\n#       3. 参考として、この時 `obj.changed?` は `true` を返す\n# 2. initializeメソッドはハッシュを受け取り、attr_accessorで作成したアトリビュートと同名のキーがあれば、自動でインスタンス変数に記録する\n#   1. ただし、この動作をwriterメソッドの履歴に残してはいけない\n# 3. 履歴がある場合、すべての操作履歴を放棄し、値も初期状態に戻す `restore!` メソッドを作成する\n\nmodule SimpleModel\nend",
  "answerCode": "# 問題の解説\n#\n# includeされたクラスのattr_accessorメソッドの挙動を変更するために、まずincludedフックメソッドを利用します。\n#\n# 初期値を管理する`_histories`と`_initial`属性をattr_accessorで用意しておきます。\n# historiesやinitialといった名前はクラスのメソッド定義などと衝突する可能性が高いので、`_`を先頭につけて回避するようにしています。\n# `_histories`は、writerメソッドを呼び出した時に、その値を記憶するためのハッシュです。キーは属性名、値はその属性に対する書き込み履歴の配列です。\n# `_initial`は、初期値を記憶するためのハッシュです。キーは属性名、値はその属性の初期値です。\n#\n# includedの中で対象のクラスをextendして、クラスメソッドであるattr_accessorメソッドを再定義します。\n# readerメソッドは通常通りの動作を行う、と仕様にあるのでattr_readerを呼び出しています。\n# writerメソッドは、通常に加え以下の動作を行うと仕様にあるので、独自に定義します。writerメソッドの中で、`_histories`に書き込み履歴を追記させています。\n# そのうえで、instance_variable_setで属性の値を書き換えています。\n#\n# initializeメソッドを定義し、`_initial`と`_histories`の初期化と`_initial`への初期値の記憶を行っています。\n# 残りの`restore`, `changed?`, `ATTR_changed?`メソッドは、`_initial`と`_histories`を活用することで問題なく実装できるはずです。\n#\nmodule SimpleModel\n  def self.included(klass)\n    klass.attr_accessor :_histories, :_initial\n    klass.extend(ClassMethods)\n  end\n\n  def initialize(args = {})\n    self._initial = args\n    self._histories = {}\n    args.each do |key, value|\n      instance_variable_set(\"@#{key}\", value)\n    end\n  end\n\n  def restore!\n    self._histories = {}\n    _initial.each do |key, value|\n      instance_variable_set(\"@#{key}\", value)\n    end\n  end\n\n  def changed?\n    !_histories.empty?\n  end\n\n  module ClassMethods\n    def attr_accessor(*syms)\n      syms.each { |sym| attr_reader sym }\n      syms.each do |sym|\n        define_method \"#{sym}=\" do |value|\n          (_histories[sym] ||= []).push(value)\n          instance_variable_set(\"@#{sym}\", value)\n        end\n\n        define_method \"#{sym}_changed?\" do\n          !!_histories[sym]\n        end\n      end\n    end\n  end\nend",
  "testCode": "require 'minitest'\n\nclass TestSimpleModel < Minitest::Test\n  class Product\n    include SimpleModel\n\n    attr_accessor :name, :description\n  end\n\n  def test_accessor\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    assert_equal 'SmarterHR', obj.name\n    assert_equal 'more smart SmartHR', obj.description\n  end\n\n  def test_writer\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = 'Ultra SmarterHR'\n    obj.description = 'more smart SmarterHR'\n    assert_equal 'Ultra SmarterHR', obj.name\n    assert_equal 'more smart SmarterHR', obj.description\n  end\n\n  def test_watching_not_changes_attrs\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    assert_equal false, obj.changed?\n  end\n\n  def test_watching_changes_attrs\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = 'SuperSmarterHR'\n    assert_equal true, obj.changed?\n  end\n\n  def test_watching_changes_each_attrs\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = 'SuperSmarterHR'\n    assert_equal true, obj.name_changed?\n    assert_equal false, obj.description_changed?\n  end\n\n  def test_restore_changes\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = 'Ultra SmarterHR'\n    obj.description = 'more smart SmarterHR'\n    obj.restore!\n    assert_equal 'SmarterHR', obj.name\n    assert_equal 'more smart SmartHR', obj.description\n    assert_equal false, obj.changed?\n  end\n\n  def test_random_read\n    name  = SecureRandom.hex\n    desc  = SecureRandom.hex\n    obj = Product.new(name: name, description: desc)\n    assert_equal name, obj.name\n    assert_equal desc, obj.description\n  end\n\n  def test_random_write\n    name  = SecureRandom.hex\n    desc  = SecureRandom.hex\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = name\n    obj.description = desc\n    assert_equal name, obj.name\n    assert_equal desc, obj.description\n  end\n\n  class MultipleAccessorsProduct\n    include SimpleModel\n\n    attr_accessor :name\n    attr_accessor :description\n  end\n\n  def test_multiple_accessors\n    obj = MultipleAccessorsProduct.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    assert_equal 'SmarterHR', obj.name\n    assert_equal 'more smart SmartHR', obj.description\n  end\n\n  def test_multiple_accessors_writer\n    obj = MultipleAccessorsProduct.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = 'Ultra SmarterHR'\n    obj.description = 'more smart SmarterHR'\n    assert_equal 'Ultra SmarterHR', obj.name\n    assert_equal 'more smart SmarterHR', obj.description\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
};

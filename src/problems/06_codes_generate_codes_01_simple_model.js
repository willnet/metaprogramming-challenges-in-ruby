// Simple Model
export const problem = {
  "section": "06_codes_generate_codes",
  "id": "01_simple_model",
  "title": "Simple Model",
  "title_en": "Simple Model",
  "description": "ActiveRecordライクなモデルの実装問題。変更追跡機能付きのattr_accessorとrestoreメソッドを学びます。",
  "description_en": "An ActiveRecord-like model implementation problem. Learn about attr_accessor with change tracking functionality and restore method.",
  "detailedDescription": "次の仕様を満たす、SimpleModelモジュールを作成してください\n\n1. include されたクラスがattr_accessorを使用すると、以下の追加動作を行う\n  1. 作成したアクセサのreaderメソッドは、通常通りの動作を行う\n  2. 作成したアクセサのwriterメソッドは、通常に加え以下の動作を行う\n    1. 何らかの方法で、writerメソッドを利用した値の書き込み履歴を記憶する\n    2. いずれかのwriterメソッド経由で更新をした履歴がある場合、 `true` を返すメソッド `changed?` を作成する\n    3. 個別のwriterメソッド経由で更新した履歴を取得できるメソッド、 `ATTR_changed?` を作成する\n      1. 例として、`attr_accessor :name, :desc`　とした時、このオブジェクトに対して `obj.name = 'hoge'` という操作を行ったとする\n      2. `obj.name_changed?` は `true` を返すが、 `obj.desc_changed?` は `false` を返す\n      3. 参考として、この時 `obj.changed?` は `true` を返す\n2. initializeメソッドはハッシュを受け取り、attr_accessorで作成したアトリビュートと同名のキーがあれば、自動でインスタンス変数に記録する\n  1. ただし、この動作をwriterメソッドの履歴に残してはいけない\n3. 履歴がある場合、すべての操作履歴を放棄し、値も初期状態に戻す `restore!` メソッドを作成する",
  "detailedDescription_en": "Create a SimpleModel module that meets the following specifications\n\n1. When an included class uses attr_accessor, it performs the following additional actions\n  1. The created accessor's reader method performs normal operations\n  2. The created accessor's writer method performs the following in addition to normal operations\n    1. By some method, remember the history of value writes using the writer method\n    2. If there is a history of updates via any writer method, create a method `changed?` that returns `true`\n    3. Create a method `ATTR_changed?` that can retrieve the history of updates via individual writer methods\n      1. As an example, when `attr_accessor :name, :desc` is used, suppose the operation `obj.name = 'hoge'` is performed on this object\n      2. `obj.name_changed?` returns `true`, but `obj.desc_changed?` returns `false`\n      3. For reference, `obj.changed?` returns `true` at this time\n2. The initialize method receives a hash and automatically records it in instance variables if there are keys with the same name as attributes created by attr_accessor\n  1. However, this action must not be recorded in the writer method history\n3. If there is history, create a `restore!` method that discards all operation history and returns values to their initial state",
  "problemCode": "module SimpleModel\nend\n",
  "answerExplanation": "問題の解説\n\nincludeされたクラスのattr_accessorメソッドの挙動を変更するために、まずincludedフックメソッドを利用します。\n\n初期値を管理する`_histories`と`_initial`属性をattr_accessorで用意しておきます。\nhistoriesやinitialといった名前はクラスのメソッド定義などと衝突する可能性が高いので、`_`を先頭につけて回避するようにしています。\n`_histories`は、writerメソッドを呼び出した時に、その値を記憶するためのハッシュです。キーは属性名、値はその属性に対する書き込み履歴の配列です。\n`_initial`は、初期値を記憶するためのハッシュです。キーは属性名、値はその属性の初期値です。\n\nincludedの中で対象のクラスをextendして、クラスメソッドであるattr_accessorメソッドを再定義します。\nreaderメソッドは通常通りの動作を行う、と仕様にあるのでattr_readerを呼び出しています。\nwriterメソッドは、通常に加え以下の動作を行うと仕様にあるので、独自に定義します。writerメソッドの中で、`_histories`に書き込み履歴を追記させています。\nそのうえで、instance_variable_setで属性の値を書き換えています。\n\ninitializeメソッドを定義し、`_initial`と`_histories`の初期化と`_initial`への初期値の記憶を行っています。\n残りの`restore`, `changed?`, `ATTR_changed?`メソッドは、`_initial`と`_histories`を活用することで問題なく実装できるはずです。",
  "answerExplanation_en": "Quiz Explanation\n\nTo change the behavior of the attr_accessor method of the included class, we first use the included hook method.\n\nWe prepare `_histories` and `_initial` attributes with attr_accessor to manage initial values.\nNames like histories and initial are likely to conflict with class method definitions, so we avoid this by prefixing with `_`.\n`_histories` is a hash to remember values when the writer method is called. The key is the attribute name, and the value is an array of write history for that attribute.\n`_initial` is a hash to remember initial values. The key is the attribute name, and the value is the initial value of that attribute.\n\nInside included, we extend the target class and redefine the attr_accessor class method.\nThe reader method performs normal operations as specified, so we call attr_reader.\nThe writer method performs additional operations as specified, so we define it independently. Inside the writer method, we append the write history to `_histories`.\nThen we rewrite the attribute value with instance_variable_set.\n\nWe define the initialize method to initialize `_initial` and `_histories` and remember initial values in `_initial`.\nThe remaining `restore`, `changed?`, and `ATTR_changed?` methods should be implementable without problems by utilizing `_initial` and `_histories`.",
  "answerCode": "module SimpleModel\n  def self.included(klass)\n    klass.attr_accessor :_histories, :_initial\n    klass.extend(ClassMethods)\n  end\n\n  def initialize(args = {})\n    self._initial = args\n    self._histories = {}\n    args.each do |key, value|\n      instance_variable_set(\"@#{key}\", value)\n    end\n  end\n\n  def restore!\n    self._histories = {}\n    _initial.each do |key, value|\n      instance_variable_set(\"@#{key}\", value)\n    end\n  end\n\n  def changed?\n    !_histories.empty?\n  end\n\n  module ClassMethods\n    def attr_accessor(*syms)\n      syms.each { |sym| attr_reader sym }\n      syms.each do |sym|\n        define_method \"#{sym}=\" do |value|\n          (_histories[sym] ||= []).push(value)\n          instance_variable_set(\"@#{sym}\", value)\n        end\n\n        define_method \"#{sym}_changed?\" do\n          !!_histories[sym]\n        end\n      end\n    end\n  end\nend\n",
  "testCode": "require 'minitest'\n\nclass TestSimpleModel < Minitest::Test\n  class Product\n    include SimpleModel\n\n    attr_accessor :name, :description\n  end\n\n  def test_accessor\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    assert_equal 'SmarterHR', obj.name\n    assert_equal 'more smart SmartHR', obj.description\n  end\n\n  def test_writer\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = 'Ultra SmarterHR'\n    obj.description = 'more smart SmarterHR'\n    assert_equal 'Ultra SmarterHR', obj.name\n    assert_equal 'more smart SmarterHR', obj.description\n  end\n\n  def test_watching_not_changes_attrs\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    assert_equal false, obj.changed?\n  end\n\n  def test_watching_changes_attrs\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = 'SuperSmarterHR'\n    assert_equal true, obj.changed?\n  end\n\n  def test_watching_changes_each_attrs\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = 'SuperSmarterHR'\n    assert_equal true, obj.name_changed?\n    assert_equal false, obj.description_changed?\n  end\n\n  def test_restore_changes\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = 'Ultra SmarterHR'\n    obj.description = 'more smart SmarterHR'\n    obj.restore!\n    assert_equal 'SmarterHR', obj.name\n    assert_equal 'more smart SmartHR', obj.description\n    assert_equal false, obj.changed?\n  end\n\n  def test_random_read\n    name  = SecureRandom.hex\n    desc  = SecureRandom.hex\n    obj = Product.new(name: name, description: desc)\n    assert_equal name, obj.name\n    assert_equal desc, obj.description\n  end\n\n  def test_random_write\n    name  = SecureRandom.hex\n    desc  = SecureRandom.hex\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = name\n    obj.description = desc\n    assert_equal name, obj.name\n    assert_equal desc, obj.description\n  end\n\n  class MultipleAccessorsProduct\n    include SimpleModel\n\n    attr_accessor :name, :description\n  end\n\n  def test_multiple_accessors\n    obj = MultipleAccessorsProduct.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    assert_equal 'SmarterHR', obj.name\n    assert_equal 'more smart SmartHR', obj.description\n  end\n\n  def test_multiple_accessors_writer\n    obj = MultipleAccessorsProduct.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = 'Ultra SmarterHR'\n    obj.description = 'more smart SmarterHR'\n    assert_equal 'Ultra SmarterHR', obj.name\n    assert_equal 'more smart SmarterHR', obj.description\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend\n"
};

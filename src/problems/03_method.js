export const methodProblems = [
  {
    "section": "03_method",
    "id": "01_method_first_step",
    "title": "Method First Step",
    "description": "Rubyのメソッド定義についての基本的な問題。defキーワードを使わない動的なメソッド定義を学びます。",
    "problemCode": "# Q1.\n# 次の動作をする F1 class を実装する\n# - 1. \"def\"キーワードを使わずにF1クラスにhelloインスタンスメソッドを定義すること\n#      戻り値は \"hello\" であること\n# - 2. \"def\"キーワードを使わずにF1クラスにworldクラスメソッドを定義すること\n#      戻り値は \"world\" であること\n# - 3. 定義していないメソッドを実行したときにエラーを発生させず、\"NoMethodError\"という文字列を返すこと\n# - 4. `F1.new.respond_to?(定義していないメソッド名)` を実行したときにtrueを返すこと\n\nclass F1\nend\n\n# Q2.\n# 次の動作をする F2 classを実装する\n# - 1. 実行するとhiインスタンスメソッドを定義するadd_hiメソッドを定義すること\n\nclass F2\nend",
    "answerCode": "# Q1. 問題の解説\n#\n# define_methodとdefine_singleton_methodとmethod_missingの素振り用の問題です。\n# define_singleton_methodは3章にはまだ出てきていませんが、これを知らないと3章の問題を解くのが難しくなるので覚えておいてください\n# respond_to_missing?は、respond_to?メソッド実行時にメソッドが定義されていない場合に呼ばれるメソッドです。method_missingを定義する場合は\n# 必ず定義しておきましょう。\n#\nclass F1\n  define_method :hello do\n    'hello'\n  end\n\n  define_singleton_method :world do\n    'world'\n  end\n\n  def method_missing(*args)\n    'NoMethodError'\n  end\n\n  def respond_to_missing?(*args)\n    true\n  end\nend\n\n# Q2. 問題の解説\n#\n# メソッドを実行したら新しいメソッドができる、ということを実感してもらうための問題です。この回答のようなdefがネストする実装は普通はやりませんが、\n# 「特定の処理を実行する時に動的にメソッドを生やす」という場面は、メタプロをしていればそれなりにあります。\n#\nclass F2\n  def add_hi\n    def hi\n    end\n  end\nend",
    "testCode": "require 'minitest'\n\nclass TestMethodFirstStep < Minitest::Test\n  def test_hello\n    assert_equal F1.new.hello, 'hello'\n  end\n\n  def test_world\n    assert_equal F1.world, 'world'\n  end\n\n  def test_method_missing\n    assert_equal F1.new.send(SecureRandom.alphanumeric), 'NoMethodError'\n  end\n\n  def test_respond_to\n    assert F1.new.respond_to?(SecureRandom.alphanumeric)\n  end\n\n  def test_add_hi\n    f2 = F2.new\n    refute f2.respond_to?(:hi)\n    f2.add_hi\n    assert f2.respond_to?(:hi)\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "03_method",
    "id": "02_define",
    "title": "Define",
    "description": "Rubyのメソッド定義と呼び出しについての問題。動的なメソッド定義やオリジナルアクセサの実装を学びます。",
    "problemCode": "# Q1.\n# 次の動作をする A1 class を実装する\n# - \"//\" を返す \"//\"メソッドが存在すること\n\n# Q2.\n# 次の動作をする A2 class を実装する\n# - 1. \"SmartHR Dev Team\"と返すdev_teamメソッドが存在すること\n# - 2. initializeに渡した配列に含まれる値に対して、\"hoge_\" をprefixを付与したメソッドが存在すること\n# - 2で定義するメソッドは下記とする\n#   - 受け取った引数の回数分、メソッド名を繰り返した文字列を返すこと\n#   - 引数がnilの場合は、dev_teamメソッドを呼ぶこと\n# - また、2で定義するメソッドは以下を満たすものとする\n#   - メソッドが定義されるのは同時に生成されるオブジェクトのみで、別のA2インスタンスには（同じ値を含む配列を生成時に渡さない限り）定義されない\n\n# Q3.\n# 次の動作をする OriginalAccessor モジュール を実装する\n# - OriginalAccessorモジュールはincludeされたときのみ、my_attr_accessorメソッドを定義すること\n# - my_attr_accessorはgetter/setterに加えて、boolean値を代入した際のみ真偽値判定を行うaccessorと同名の?メソッドができること",
    "answerCode": "# Q1.\n#\n# 問題の解説\n# defだとSyntaxErrorになってしまうようなメソッド名でも、define_methodを使うことでメソッドとして定義することができます。\n#\nclass A1\n  define_method '//' do\n    '//'\n  end\nend\n\n# Q2\n#\n# 問題の解説\n# defind_singleton_methodを利用して動的に特異メソッドを定義することで、条件2を満たしています。\n# define_methodはModuleのインスタンスメソッドなので、initializeメソッド中では使えません。\n# A2.define_methodのようにすれば使えますが、それだとA2クラスのインスタンスメソッドになるので\n# すべてのA2インスタンスで利用できてしまい、\n# 「メソッドが定義されるのは同時に生成されるオブジェクトのみで、別のA2インスタンスには（同じ値を含む配列を生成時に渡さない限り）定義されない」\n# という仕様を満たすことができません。\n#\nclass A2\n  def initialize(ary)\n    ary.each do |name|\n      method_name = \"hoge_#{name}\"\n\n      define_singleton_method method_name do |times|\n        if times.nil?\n          dev_team\n        else\n          method_name * times\n        end\n      end\n    end\n  end\n\n  def dev_team\n    'SmartHR Dev Team'\n  end\nend\n\n# Q3.\n#\n# 問題の解説\n# 3章にはまだ登場していない概念ですが、includedフックを利用してモジュールがincludeされたときの振る舞いを記述しています。\n# my_attr_accessorメソッドはクラスメソッドに相当するため、includedメソッドの引数として渡されてきたクラスに直接define_singleton_methodでメソッドを追加しています。\n# さらにmy_attr_accessorメソッド実行時にインスタンスメソッドを追加するためにdefine_methodを利用しています。\n# セッターで定義した値を格納するために`@my_attr_accessor`をハッシュとして定義して利用しています。\n# `?`つきのメソッドを定義するために、セッター実行時にdefine_aingleton_methodでメソッドを追加しています。\n#\nmodule OriginalAccessor\n  def self.included(base)\n    base.define_singleton_method(:my_attr_accessor) do |attr|\n      base.define_method attr do\n        @my_attr_accessor&.fetch(attr) { nil }\n      end\n\n      base.define_method \"#{attr}=\" do |value|\n        (@my_attr_accessor ||= {})[attr] = value\n\n        if value.is_a?(TrueClass) || value.is_a?(FalseClass)\n          define_singleton_method \"#{attr}?\" do\n            !!value\n          end\n        end\n      end\n    end\n  end\nend",
    "testCode": "require 'minitest'\nrequire 'securerandom'\n\nclass TestDefine < Minitest::Test\n\n  begin\n    class A3\n      include OriginalAccessor\n      my_attr_accessor :hoge\n      my_attr_accessor :fuga\n    end\n  rescue\n  end\n\n  def test_answer_a1\n    assert_equal \"//\", A1.new.send(\"//\".to_sym)\n  end\n\n  def test_answer_a1_define\n    assert_equal true, A1.new.methods.include?(\"//\".to_sym)\n  end\n\n  def test_answer_a2\n    instance = A2.new([\"hoge\", \"fuga\"])\n\n    assert_equal true, instance.methods.include?(:dev_team)\n    assert_equal \"SmartHR Dev Team\", instance.hoge_hoge(nil)\n    assert_equal \"hoge_hogehoge_hoge\", instance.hoge_hoge(2)\n    assert_equal \"hoge_fugahoge_fugahoge_fuga\", instance.hoge_fuga(3)\n\n    another_instance = A2.new([])\n    assert_equal false, another_instance.methods.include?(:hoge_hoge)\n    assert_equal false, another_instance.methods.include?(:hoge_fuga)\n  end\n\n  def test_answer_a2_number\n    instance = A2.new([1, 2])\n\n    assert_equal true, instance.methods.include?(:dev_team)\n    assert_equal \"SmartHR Dev Team\", instance.hoge_1(nil)\n    assert_equal \"hoge_1hoge_1\", instance.hoge_1(2)\n    assert_equal \"hoge_2hoge_2hoge_2\", instance.hoge_2(3)\n\n    another_instance = A2.new([])\n    assert_equal false, another_instance.methods.include?(:hoge_1)\n    assert_equal false, another_instance.methods.include?(:hoge_2)\n  end\n\n  def test_answer_a2_random_name\n    value_one = SecureRandom.hex\n    value_two = SecureRandom.hex\n\n    instance = A2.new([value_one, value_two])\n    assert_equal true, instance.methods.include?(:dev_team)\n    assert_equal \"SmartHR Dev Team\", instance.send(\"hoge_#{value_one}\".to_sym, nil)\n    assert_equal \"hoge_#{value_one}hoge_#{value_one}\", instance.send(\"hoge_#{value_one}\".to_sym, 2)\n    assert_equal \"hoge_#{value_two}hoge_#{value_two}hoge_#{value_two}\", instance.send(\"hoge_#{value_two}\".to_sym, 3)\n\n    another_instance = A2.new([])\n    assert_equal false, another_instance.methods.include?(\"hoge_#{value_one}\".to_sym)\n    assert_equal false, another_instance.methods.include?(\"hoge_#{value_two}\".to_sym)\n  end\n\n  def test_answer_a2_called_dev_team\n    instance = A2.new([1])\n\n    @called_dev_team = false\n    trace = TracePoint.new(:call) do |tp|\n      @called_dev_team = tp.event == :call && tp.method_id == :dev_team unless @called_dev_team\n    end\n    trace.enable\n    instance.hoge_1(nil)\n    trace.disable\n\n    assert_equal true, @called_dev_team\n  end\n\n  def test_answer_a3_define\n    assert_equal true, A3.methods.include?(:my_attr_accessor)\n  end\n\n  def test_answer_a3_string\n    instance = A3.new\n    instance.hoge = \"1\"\n\n    assert_equal false, instance.methods.include?(:hoge?)\n    assert_equal \"1\", instance.hoge\n  end\n\n  def test_answer_a3_number\n    instance = A3.new\n    instance.hoge = 1\n\n    assert_equal false, instance.methods.include?(:hoge?)\n    assert_equal 1, instance.hoge\n  end\n\n  def test_answer_a3_array\n    instance = A3.new\n    instance.hoge = [1, 2]\n\n    assert_equal false, instance.methods.include?(:hoge?)\n    assert_equal [1, 2], instance.hoge\n  end\n\n  def test_answer_a3_boolean_true\n    instance = A3.new\n    instance.hoge = true\n    assert_equal true, instance.methods.include?(:hoge?)\n    assert_equal true, instance.hoge?\n  end\n\n  def test_answer_a3_boolean_false\n    instance = A3.new\n    instance.hoge = false\n    assert_equal true, instance.methods.include?(:hoge?)\n    assert_equal false, instance.hoge?\n  end\n\n  def test_answer_a3_multiple\n    instance = A3.new\n    instance.hoge = \"hoge\"\n    instance.fuga = \"fuga\"\n    assert_equal \"hoge\", instance.hoge\n    assert_equal \"fuga\", instance.fuga\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "03_method",
    "id": "03_try_over3_3",
    "title": "Try Over3 3",
    "description": "高度なメタプログラミング技術の問題。method_missing、プロキシオブジェクト、const_missing、DSLの実装などを学びます。",
    "problemCode": "TryOver3 = Module.new\n# Q1\n# 以下要件を満たすクラス TryOver3::A1 を作成してください。\n# - run_test というインスタンスメソッドを持ち、それはnilを返す\n# - `test_` から始まるインスタンスメソッドが実行された場合、このクラスは `run_test` メソッドを実行する\n# - `test_` メソッドがこのクラスに実装されていなくても `test_` から始まるメッセージに応答することができる\n# - TryOver3::A1 には `test_` から始まるインスタンスメソッドが定義されていない\n\n\n# Q2\n# 以下要件を満たす TryOver3::A2Proxy クラスを作成してください。\n# - TryOver3::A2Proxy は initialize に TryOver3::A2 のインスタンスを受け取り、それを @source に代入する\n# - TryOver3::A2Proxy は、@sourceに定義されているメソッドが自分自身に定義されているように振る舞う\nclass TryOver3::A2\n  def initialize(name, value)\n    instance_variable_set(\"@#{name}\", value)\n    self.class.attr_accessor name.to_sym unless respond_to? name.to_sym\n  end\nend\n\n\n# Q3.\n# 02_define.rbのQ3ではOriginalAccessor の my_attr_accessor で定義した getter/setter に\n# boolean の値が入っている場合には #{name}? が定義されるようなモジュールを実装しました。\n# 今回は、そのモジュールに boolean 以外が入っている場合には #{name}? メソッドが存在しないようにする変更を加えてください。\n# （以下のコードに変更を加えてください）\n#\nmodule TryOver3::OriginalAccessor2\n  def self.included(mod)\n    mod.define_singleton_method :my_attr_accessor do |name|\n      define_method name do\n        @attr\n      end\n\n      define_method \"#{name}=\" do |value|\n        if [true, false].include?(value) && !respond_to?(\"#{name}?\")\n          self.class.define_method \"#{name}?\" do\n            @attr == true\n          end\n        end\n        @attr = value\n      end\n    end\n  end\nend\n\n\n# Q4\n# 以下のように実行できる TryOver3::A4 クラスを作成してください。\n# TryOver3::A4.runners = [:Hoge]\n# TryOver3::A4::Hoge.run\n# # => \"run Hoge\"\n# このとき、TryOver3::A4::Hogeという定数は定義されません。\n\n\n# Q5. チャレンジ問題！ 挑戦する方はテストの skip を外して挑戦してみてください。\n#\n# TryOver3::TaskHelper という include すると task というクラスマクロが与えられる以下のようなモジュールがあります。\nmodule TryOver3::TaskHelper\n  def self.included(klass)\n    klass.define_singleton_method :task do |name, &task_block|\n      new_klass = Class.new do\n        define_singleton_method :run do\n          puts \"start #{Time.now}\"\n          block_return = task_block.call\n          puts \"finish #{Time.now}\"\n          block_return\n        end\n      end\n      new_klass_name = name.to_s.split(\"_\").map{ |w| w[0] = w[0].upcase; w }.join\n      const_set(new_klass_name, new_klass)\n    end\n  end\nend\n\n# TryOver3::TaskHelper は include することで以下のような使い方ができます\nclass TryOver3::A5Task\n  include TryOver3::TaskHelper\n\n  task :foo do\n    \"foo\"\n  end\nend\n# irb(main):001:0> TryOver3::A3Task::Foo.run\n# start 2020-01-07 18:03:10 +0900\n# finish 2020-01-07 18:03:10 +0900\n# => \"foo\"\n\n# 今回 TryOver3::TaskHelper では TryOver3::A5Task::Foo のように Foo クラスを作らず\n# TryOver3::A5Task.foo のようにクラスメソッドとして task で定義された名前のクラスメソッドでブロックを実行するように変更したいです。\n# 現在 TryOver3::TaskHelper のユーザには TryOver3::A5Task::Foo.run のように生成されたクラスを使って実行しているユーザが存在します。\n# 今回変更を加えても、その人たちにはこれまで通り生成されたクラスのrunメソッドでタスクを実行できるようにしておいて、\n# warning だけだしておくようにしたいです。\n# TryOver3::TaskHelper を修正してそれを実現してください。 なお、その際、クラスは実行されない限り生成されないものとします。\n#\n# 変更後想定する使い方\n# メソッドを使ったケース\n# irb(main):001:0> TryOver3::A5Task.foo\n# start 2020-01-07 18:03:10 +0900\n# finish 2020-01-07 18:03:10 +0900\n# => \"foo\"\n#\n# クラスのrunメソッドを使ったケース\n# irb(main):001:0> TryOver3::A5Task::Foo.run\n# Warning: TryOver3::A5Task::Foo.run is deprecated\n# start 2020-01-07 18:03:10 +0900\n# finish 2020-01-07 18:03:10 +0900\n# => \"foo\"",
    "answerCode": "TryOver3 = Module.new\n# Q1. 問題の解説\n#\n# method_missingを利用してゴーストメソッドを作る問題です。\n# respond_to_missing?はなくてもテストはパスしますが、method_missingを作るときにはセットで\n# 定義しておくのがお作法なので回答例にはrespond_to_missing?も定義しています。\n#\nclass TryOver3::A1\n  def run_test\n  end\n\n  def method_missing(name, *)\n    if name.to_s.start_with?('test_')\n      run_test\n    else\n      super\n    end\n  end\n\n  def respond_to_missing?(name, _)\n    name.to_s.start_with?('test_')\n  end\nend\n\n# Q2. 問題の解説\n#\n# method_missingとsendを使って動的プロキシを作る問題です。\n# Q1と違い、こちらはrespond_to_missing?がないとテストが失敗します。\n#\nclass TryOver3::A2\n  def initialize(name, value)\n    instance_variable_set(\"@#{name}\", value)\n    self.class.attr_accessor name.to_sym unless respond_to? name.to_sym\n  end\nend\n\nclass TryOver3::A2Proxy\n  def initialize(source)\n    @source = source\n  end\n\n  def method_missing(...)\n    @source.send(...)\n  end\n\n  def respond_to_missing?(name, include_all)\n    @source.respond_to?(name, include_all)\n  end\nend\n\n# Q3.\n# Module#remove_methodを利用するとメソッドを削除できます。これを使い、\n# 「boolean 以外が入っている場合には #{name}? メソッドが存在しないようにする」を実現します。\n# なお、メソッドを削除するメソッドはremove_methodの他にundef_methodも存在します。こちらでもテストはパスします。\n# remove_methodとundef_methodの違いが気になる方はドキュメントを読んでみてください。\n#\nmodule TryOver3::OriginalAccessor2\n  def self.included(mod)\n    mod.define_singleton_method :my_attr_accessor do |name|\n      define_method name do\n        @attr\n      end\n\n      define_method \"#{name}=\" do |value|\n        if [true, false].include?(value) && !respond_to?(\"#{name}?\")\n          self.class.define_method \"#{name}?\" do\n            @attr == true\n          end\n        else\n          mod.remove_method \"#{name}?\" if respond_to? \"#{name}?\"\n        end\n        @attr = value\n      end\n    end\n  end\nend\n\n\n# Q4. 問題の解説\n#\n# const_missingを利用して、runners=で定義した定数を参照したときにrunメソッドを持つオブジェクトを返すことで\n# 仕様を満たしています。回答例ではObject.newでオブジェクトを生成しましたが、runメソッドを持つオブジェクトであれば\n# どんなクラスのインスタンスでもOKです。\n#\nclass TryOver3::A4\n  def self.const_missing(const)\n    if @consts.include?(const)\n      obj = Object.new\n      obj.define_singleton_method(:run) { \"run #{const}\" }\n      obj\n    else\n      super\n    end\n  end\n\n  def self.runners=(consts)\n    @consts = consts\n  end\nend\n\n# Q5. 問題の解説\n#\n# これまで解いてきた問題の解法と、仕様を読み解く知識が問われる問題です。\n# 2種類の書き方で同一の処理を行うが、そのうち1つは追加でdeprecation warningを出します。\n# メソッドの実態はdefine_singleton_methodで定義し、もう1つはQ4と同様にconst_misisingを使い、\n# runメソッド実行時にsendでもともとの定義を呼びだします。\n#\n# taskで定義されていないタスク名を定数として参照したときは既存のconst_missingの処理を継続させたいので\n# superを実行しています。\n\nmodule TryOver3::TaskHelper\n  def self.included(klass)\n    klass.define_singleton_method :task do |name, &task_block|\n      define_singleton_method name do\n        puts \"start #{Time.now}\"\n        block_return = task_block.call\n        puts \"finish #{Time.now}\"\n        block_return\n      end\n\n      define_singleton_method(:const_missing) do |const|\n        super(const) unless klass.respond_to?(const.downcase)\n\n        obj = Object.new\n        obj.define_singleton_method :run do\n          warn \"Warning: TryOver3::A5Task::#{const}.run is deprecated\"\n          klass.send name\n        end\n        obj\n      end\n    end\n  end\nend\n\nclass TryOver3::A5Task\n  include TryOver3::TaskHelper\n\n  task :foo do\n    \"foo\"\n  end\nend",
    "testCode": "require 'minitest'\nrequire 'minitest/mock'\n\nclass TestTryOver03Q1 < Minitest::Test\n  def test_q1_called_run_test\n    a1 = TryOver3::A1.new\n    mock = Minitest::Mock.new\n    a1.stub(:run_test, mock) do\n      a1.test_hoge\n    end\n    assert mock.verify\n  end\n\n  def test_q1_run_raise_error\n    assert_raises(NoMethodError) { TryOver3::A1.new.testhoge }\n  end\n\n  def test_q1_methods_not_included_test\n    assert_equal false, TryOver3::A1.instance_methods(false).any? { |method_name| method_name.to_s.start_with?(\"test_\") }\n  end\n\n  def test_q2_proxy_foo\n    source = TryOver3::A2.new(\"foo\", \"foofoo\")\n    assert_equal \"foofoo\", TryOver3::A2Proxy.new(source).foo\n  end\n\n  def test_q2_proxy_hoge_writer\n    source = TryOver3::A2.new(\"foo\", \"foo\")\n    proxy = TryOver3::A2Proxy.new(source)\n    proxy.foo = \"foofoo\"\n    assert_equal \"foofoo\", proxy.foo\n  end\n\n  def test_q2_proxy_rand\n    name = alpha_rand\n    source = TryOver3::A2.new(name, \"foo\")\n    assert_equal \"foo\", TryOver3::A2Proxy.new(source).public_send(name)\n  end\n\n  def test_q2_proxy_respond_to_foo\n    source = TryOver3::A2.new(\"foo\", \"foofoo\")\n    assert_respond_to TryOver3::A2Proxy.new(source), :foo\n  end\n\n  def test_q2_proxy_methods_not_included_foo\n    source = TryOver3::A2.new(\"foo\", \"foofoo\")\n    refute_includes TryOver3::A2Proxy.new(source).methods, :foo\n  end\n\n  def test_q3_original_accessor_boolean_method\n    instance = orignal_accessor_included_instance\n    instance.hoge = true\n    assert_equal(true, instance.hoge?)\n    instance.hoge = \"hoge\"\n    assert_raises(NoMethodError) { instance.hoge? }\n    refute_includes(instance.methods, :hoge?)\n  end\n\n  def test_q3_original_accessor_boolean_method_reverse\n    instance = orignal_accessor_included_instance\n    instance.hoge = \"hoge\"\n    assert_raises(NoMethodError) { instance.hoge? }\n    refute_includes(instance.methods, :hoge?)\n    instance.hoge = true\n    assert_equal(true, instance.hoge?)\n  end\n\n  def test_q4_call_class\n    TryOver3::A4.runners = [:Hoge]\n    assert_equal \"run Hoge\", TryOver3::A4::Hoge.run\n  end\n\n  def test_q4_raise_error_when_called_not_runner_class\n    TryOver3::A4.runners = [:Hoge]\n    assert_raises(NameError) { TryOver3::A4::Foo }\n  end\n\n  def test_q4_not_exists_runner_class\n    TryOver3::A4.runners = [:Hoge]\n    refute_includes(TryOver3::A4.constants, :Hoge)\n  end\n\n  def test_q5_task_helper_call_method\n    skip unless ENV[\"CI\"]\n    assert_equal(\"foo\", TryOver3::A5Task.foo)\n  end\n\n  def test_q5_task_helper_not_exists_class\n    skip unless ENV[\"CI\"]\n    refute_includes TryOver3::A5Task.constants, :Foo\n  end\n\n  def test_q5_task_helper_call_class\n    skip unless ENV[\"CI\"]\n    assert_equal(\"foo\", TryOver3::A5Task::Foo.run)\n  end\n\n  def test_q5_task_helper_call_class_with_warn\n    skip unless ENV[\"CI\"]\n    _, err = capture_io do\n      TryOver3::A5Task::Foo.run\n    end\n    assert_match \"Warning: TryOver3::A5Task::Foo.run is deprecated\", err\n  end\n\n  def test_q5_error_when_called_not_defined_task_class\n    assert_raises(NameError) { TryOver3::A5Task::Bar.run }\n  end\n\n  private\n\n  def alpha_rand(size = 8)\n    alphabets = [*\"a\"..\"z\"]\n    (0..size).map { alphabets[rand(alphabets.size)] }.join\n  end\n\n  def orignal_accessor_included_instance\n    Class.new do\n      include TryOver3::OriginalAccessor2\n      my_attr_accessor :hoge\n    end.new\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  }
];
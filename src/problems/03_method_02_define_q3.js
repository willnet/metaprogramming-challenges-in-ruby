// Define Q3
export const problem = {
  "section": "03_method",
  "id": "02_define_q3",
  "title": "Define Q3",
  "title_en": "Define Q3",
  "description": "includeされたときにカスタムアクセサメソッドを定義するOriginalAccessorモジュールを実装します。",
  "description_en": "Implement OriginalAccessor module that defines custom accessor methods when included.",
  "detailedDescription": "次の動作をする OriginalAccessor モジュール を実装する\n\n- OriginalAccessorモジュールはincludeされたときのみ、my_attr_accessorメソッドを定義すること\n- my_attr_accessorはgetter/setterに加えて、boolean値を代入した際のみ真偽値判定を行うaccessorと同名の?メソッドができること",
  "detailedDescription_en": "Implement OriginalAccessor module that behaves as follows\n\n- The OriginalAccessor module should define the my_attr_accessor method only when included\n- my_attr_accessor should create getter/setter methods, and additionally create predicate methods (with ? suffix) only when boolean values are assigned",
  "problemCode": "module OriginalAccessor\nend\n",
  "answerExplanation": "書籍の3章にはまだ登場していない概念ですが、includedフックを利用してモジュールがincludeされたときの振る舞いを記述しています。`my_attr_accessor`メソッドはクラスメソッドに相当するため、`included`メソッドの引数として渡されてきたクラスに直接`define_singleton_method`でメソッドを追加しています。さらに`my_attr_accessor`メソッド実行時にインスタンスメソッドを追加するために`define_method`を利用しています。セッターで定義した値を格納するために`@my_attr_accessor`をハッシュとして定義して利用しています。`?`つきのメソッドを定義するために、セッター実行時にdefine_singleton_methodでメソッドを追加しています。",
  "answerExplanation_en": "Though this concept hasn't appeared in Chapter 3 of the book yet, this solution uses the `included` hook to describe behavior when the module is included. Since the `my_attr_accessor` method is equivalent to a class method, we add the method directly to the class passed as an argument to the `included` method using `define_singleton_method`. Furthermore, to add instance methods when `my_attr_accessor` is executed, we use `define_method`. To store values defined by the setter, we define and use `@my_attr_accessor` as a hash. To define methods with `?`, we add methods using `define_singleton_method` when the setter is executed.",
  "answerCode": "module OriginalAccessor\n  def self.included(base)\n    base.define_singleton_method(:my_attr_accessor) do |attr|\n      base.define_method attr do\n        @my_attr_accessor&.fetch(attr) { nil }\n      end\n\n      base.define_method \"#{attr}=\" do |value|\n        (@my_attr_accessor ||= {})[attr] = value\n\n        if value.is_a?(TrueClass) || value.is_a?(FalseClass)\n          define_singleton_method \"#{attr}?\" do\n            !!value\n          end\n        end\n      end\n    end\n  end\nend\n",
  "testCode": "require 'minitest'\nrequire 'securerandom'\n\nclass TestDefine < Minitest::Test\n  begin\n    class A3\n      include OriginalAccessor\n      my_attr_accessor :hoge\n      my_attr_accessor :fuga\n    end\n  rescue\n  end\n\n  def test_answer_a3_define\n    assert_equal true, A3.methods.include?(:my_attr_accessor)\n  end\n\n  def test_answer_a3_string\n    instance = A3.new\n    instance.hoge = \"1\"\n\n    assert_equal false, instance.methods.include?(:hoge?)\n    assert_equal \"1\", instance.hoge\n  end\n\n  def test_answer_a3_number\n    instance = A3.new\n    instance.hoge = 1\n\n    assert_equal false, instance.methods.include?(:hoge?)\n    assert_equal 1, instance.hoge\n  end\n\n  def test_answer_a3_array\n    instance = A3.new\n    instance.hoge = [1, 2]\n\n    assert_equal false, instance.methods.include?(:hoge?)\n    assert_equal [1, 2], instance.hoge\n  end\n\n  def test_answer_a3_boolean_true\n    instance = A3.new\n    instance.hoge = true\n    assert_equal true, instance.methods.include?(:hoge?)\n    assert_equal true, instance.hoge?\n  end\n\n  def test_answer_a3_boolean_false\n    instance = A3.new\n    instance.hoge = false\n    assert_equal true, instance.methods.include?(:hoge?)\n    assert_equal false, instance.hoge?\n  end\n\n  def test_answer_a3_multiple\n    instance = A3.new\n    instance.hoge = \"hoge\"\n    instance.fuga = \"fuga\"\n    assert_equal \"hoge\", instance.hoge\n    assert_equal \"fuga\", instance.fuga\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
};

// Simple Mock
export const problem = {
  "section": "05_class_definition",
  "id": "02_simple_mock",
  "title": "Simple Mock",
  "description": "シンプルなモックフレームワークの作成問題。モックオブジェクトの作成、メソッド呼び出し回数の追跡などを学びます。",
  "problemCode": "# 次の仕様を満たすモジュール SimpleMock を作成してください\n#\n# SimpleMockは、次の2つの方法でモックオブジェクトを作成できます\n# 特に、2の方法では、他のオブジェクトにモック機能を付与します\n# この時、もとのオブジェクトの能力が失われてはいけません\n# また、これの方法で作成したオブジェクトを、以後モック化されたオブジェクトと呼びます\n# 1.\n# ```\n# SimpleMock.new\n# ```\n#\n# 2.\n# ```\n# obj = SomeClass.new\n# SimpleMock.mock(obj)\n# ```\n#\n# モック化したオブジェクトは、expectsメソッドに応答します\n# expectsメソッドには2つの引数があり、それぞれ応答を期待するメソッド名と、そのメソッドを呼び出したときの戻り値です\n# ```\n# obj = SimpleMock.new\n# obj.expects(:imitated_method, true)\n# obj.imitated_method #=> true\n# ```\n# モック化したオブジェクトは、expectsの第一引数に渡した名前のメソッド呼び出しに反応するようになります\n# そして、第2引数に渡したオブジェクトを返します\n#\n# モック化したオブジェクトは、watchメソッドとcalled_timesメソッドに応答します\n# これらのメソッドは、それぞれ1つの引数を受け取ります\n# watchメソッドに渡した名前のメソッドが呼び出されるたび、モック化したオブジェクトは内部でその回数を数えます\n# そしてその回数は、called_timesメソッドに同じ名前の引数が渡された時、その時点での回数を参照することができます\n# ```\n# obj = SimpleMock.new\n# obj.expects(:imitated_method, true)\n# obj.watch(:imitated_method)\n# obj.imitated_method #=> true\n# obj.imitated_method #=> true\n# obj.called_times(:imitated_method) #=> 2\n# ```",
  "answerCode": "# 問題の解説\n# まずmockメソッドの実装から考えます。「もとのオブジェクトの能力が失われてはいけない」という仕様から、引数として受け付けたオブジェクトに\n# SimpleMockをextendすることでモック化に必要なメソッドであるexpects, watch, called_timesを追加するようにします。\n#\n# expectsメソッドを実行したとき、レシーバとなるオブジェクトにだけメソッドを追加したいのでdefine_singleton_methodを利用して動的にメソッドを追加します。\n# メソッドの内容は、次のようにexpectsメソッドに続けてwatchメソッドが実行されたときに備えて、\n# カウンター用のインスタンス変数`@counter`(キーがexpectsで指定されたメソッド名、値が実行回数のハッシュ)を用意して\n# watchが実行されていたら(つまり対応する`@counter`の値があれば)それをインクリメントするようにします。\n#\n# ```ruby\n# obj = Object.new\n# obj = SimpleMock(obj)\n# obj.expects(:hoge, true)\n# obj.watch(:hoge)\n# obj.hoge #=> true\n# ````\n#\n# また、watchを実行したときにexpects経由で定義したメソッドを上書きしないように、expectsしたメソッド名を`@expects`に配列として保存しておきます。\n# watchでは`@expects`を見て、すでにexpectsで定義済みであればメソッドを上書きしないようにします。\n# そうしないとwatchメソッドを実行したときに、モックメソッドの戻り値の情報が失われてしまいます。\n#\n# 次にnewメソッドの実装を考えます。仕様から、SimpleMockはモジュールであることを求められていますが、\n# 同時にモジュールには存在しないnewメソッドを持つようにも求められています。\n# これを、クラスメソッドのnewを明示的に定義することで満たします。このとき何らかのオブジェクトをmockメソッドの引数にして、\n# 戻り値を返すようにすれば要件は満たせますが、モック用のオブジェクトとしては余計なメソッドをなるべく持たない方が扱いやすいので、\n# Object.newをmockメソッドの引数にしています。\n#\nmodule SimpleMock\n  def self.mock(obj)\n    obj.extend(SimpleMock)\n    obj\n  end\n\n  def self.new\n    obj = Object.new\n    mock(obj)\n  end\n\n  def expects(name, value)\n    define_singleton_method(name) do\n      @counter[name] += 1 if @counter&.key?(name)\n      value\n    end\n    @expects ||= []\n    @expects.push(name.to_sym)\n  end\n\n  def watch(name)\n    (@counter ||= {})[name] = 0\n\n    return if @expects&.include?(name.to_sym)\n\n    define_singleton_method(name) do\n      @counter[name] += 1\n    end\n  end\n\n  def called_times(name)\n    @counter[name]\n  end\nend",
  "testCode": "require 'minitest'\n\nclass TestSimpleMock < Minitest::Test\n  class ClassForMockTest\n    def hoge; \"hoge\"; end\n  end\n\n  def test_mock_initialize\n    obj = SimpleMock.new\n    assert_kind_of SimpleMock, obj\n  end\n\n  def test_mock_extend\n    obj = ClassForMockTest.new\n    SimpleMock.mock(obj)\n\n    assert_kind_of SimpleMock, obj\n  end\n\n  def test_mock_retuns_setted_value_when_instance\n    obj = SimpleMock.new\n    expected = SecureRandom.hex\n    obj.expects(:imitated_method, expected)\n\n    assert_equal obj.imitated_method, expected\n  end\n\n  def test_mock_returns_setted_value_when_extended\n    obj = ClassForMockTest.new\n    SimpleMock.mock(obj)\n    expected = SecureRandom.hex\n    obj.expects(:imitated_method, expected)\n\n    assert_equal obj.imitated_method, expected\n  end\n\n  def test_mock_counts_how_many_times_called_method\n    obj = SimpleMock.mock(ClassForMockTest.new)\n    obj.watch(:hoge)\n\n    obj.hoge\n    obj.hoge\n    obj.hoge\n\n    assert_equal 3, obj.called_times(:hoge)\n  end\n\n  def test_mock_counts_how_many_times_called_mocked_method\n    obj = SimpleMock.new\n    obj.expects(:imitated_method, true)\n    obj.watch(:imitated_method)\n\n    obj.imitated_method\n    obj.imitated_method\n\n    assert_equal 2, obj.called_times(:imitated_method)\n  end\n\n  def test_mock_returns_value_and_counts_how_many_times\n    obj = SimpleMock.new\n    obj.expects(:imitated_method, 'hoge')\n    obj.watch(:imitated_method)\n\n    assert_equal('hoge', obj.imitated_method)\n    assert_equal('hoge', obj.imitated_method)\n\n    assert_equal 2, obj.called_times(:imitated_method)\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
};

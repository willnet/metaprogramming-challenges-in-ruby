// Simple Mock
export const problem = {
  "section": "05_class_definition",
  "id": "07_simple_mock",
  "title": "Simple Mock",
  "title_en": "Simple Mock",
  "description": "シンプルなモックフレームワークの作成問題。モックオブジェクトの作成、メソッド呼び出し回数の追跡などを学びます。",
  "description_en": "A problem for creating a simple mock framework. Learn about creating mock objects, tracking method call counts, etc.",
  "detailedDescription": "次の仕様を満たすモジュール SimpleMock を作成してください\n\nSimpleMockは、次の2つの方法でモックオブジェクトを作成できます。特に、2の方法では、他のオブジェクトにモック機能を付与します。この時、もとのオブジェクトの能力が失われてはいけません。また、これの方法で作成したオブジェクトを、以後モック化されたオブジェクトと呼びます\n\n1.\n\n```\nSimpleMock.new\n```\n\n2.\n\n```\nobj = SomeClass.new\nSimpleMock.mock(obj)\n```\n\nモック化したオブジェクトは、expectsメソッドに応答します。expectsメソッドには2つの引数があり、それぞれ応答を期待するメソッド名と、そのメソッドを呼び出したときの戻り値です。\n\n```\nobj = SimpleMock.new\nobj.expects(:imitated_method, true)\nobj.imitated_method #=> true\n```\n\nモック化したオブジェクトは、expectsの第一引数に渡した名前のメソッド呼び出しに反応するようになります。そして、第2引数に渡したオブジェクトを返します\n\nモック化したオブジェクトは、watchメソッドとcalled_timesメソッドに応答します。これらのメソッドは、それぞれ1つの引数を受け取ります。watchメソッドに渡した名前のメソッドが呼び出されるたび、モック化したオブジェクトは内部でその回数を数えます。そしてその回数は、called_timesメソッドに同じ名前の引数が渡された時、その時点での回数を参照することができます。\n\n```\nobj = SimpleMock.new\nobj.expects(:imitated_method, true)\nobj.watch(:imitated_method)\nobj.imitated_method #=> true\nobj.imitated_method #=> true\nobj.called_times(:imitated_method) #=> 2\n```",
  "detailedDescription_en": "Create a SimpleMock module that meets the following specifications.SimpleMock can create mock objects in the following two ways.In particular, method 2 adds mock functionality to other objects. At this time, the original object's capabilities must not be lost. Also, objects created this way will be called mocked objects hereafter.\n\n1.\n\n```\nSimpleMock.new\n```\n\n2.\n```\nobj = SomeClass.new\nSimpleMock.mock(obj)\n```\n\nMocked objects respond to the expects method. The expects method has two arguments: the method name expected to respond and the return value when that method is called.\n\n```\nobj = SimpleMock.new\nobj.expects(:imitated_method, true)\nobj.imitated_method #=> true\n```\n\nMocked objects will respond to method calls with the name passed as the first argument to expects. And returns the object passed as the second argument. Mocked objects respond to the watch method and called_times method. Each of these methods receives one argument. Every time a method with the name passed to the watch method is called, the mocked object internally counts the number of times. And that count can be referenced when the same name argument is passed to the called_times method at that point.\n\n```\nobj = SimpleMock.new\nobj.expects(:imitated_method, true)\nobj.watch(:imitated_method)\nobj.imitated_method #=> true\nobj.imitated_method #=> true\nobj.called_times(:imitated_method) #=> 2\n```",
  "problemCode": "",
  "answerExplanation": "問題の解説\nまずmockメソッドの実装から考えます。「もとのオブジェクトの能力が失われてはいけない」という仕様から、引数として受け付けたオブジェクトに\nSimpleMockをextendすることでモック化に必要なメソッドであるexpects, watch, called_timesを追加するようにします。\n\nexpectsメソッドを実行したとき、レシーバとなるオブジェクトにだけメソッドを追加したいのでdefine_singleton_methodを利用して動的にメソッドを追加します。\nメソッドの内容は、次のようにexpectsメソッドに続けてwatchメソッドが実行されたときに備えて、\nカウンター用のインスタンス変数`@counter`(キーがexpectsで指定されたメソッド名、値が実行回数のハッシュ)を用意して\nwatchが実行されていたら(つまり対応する`@counter`の値があれば)それをインクリメントするようにします。\n\n```ruby\nobj = Object.new\nobj = SimpleMock(obj)\nobj.expects(:hoge, true)\nobj.watch(:hoge)\nobj.hoge #=> true\n````\n\nまた、watchを実行したときにexpects経由で定義したメソッドを上書きしないように、expectsしたメソッド名を`@expects`に配列として保存しておきます。\nwatchでは`@expects`を見て、すでにexpectsで定義済みであればメソッドを上書きしないようにします。\nそうしないとwatchメソッドを実行したときに、モックメソッドの戻り値の情報が失われてしまいます。\n\n次にnewメソッドの実装を考えます。仕様から、SimpleMockはモジュールであることを求められていますが、\n同時にモジュールには存在しないnewメソッドを持つようにも求められています。\nこれを、クラスメソッドのnewを明示的に定義することで満たします。このとき何らかのオブジェクトをmockメソッドの引数にして、\n戻り値を返すようにすれば要件は満たせますが、モック用のオブジェクトとしては余計なメソッドをなるべく持たない方が扱いやすいので、\nObject.newをmockメソッドの引数にしています。",
  "answerExplanation_en": "Problem Explanation\nFirst, let's consider the implementation of the mock method. From the specification that \"the original object's capabilities must not be lost\", we add the methods necessary for mocking (expects, watch, called_times) by extending SimpleMock to the object received as an argument.\n\nWhen the expects method is executed, we want to add a method only to the receiver object, so we use define_singleton_method to dynamically add methods.\nThe method content prepares an instance variable `@counter` for the counter (a hash where the key is the method name specified by expects and the value is the execution count) in preparation for when the watch method is executed following the expects method,\nand increments it if watch has been executed (i.e., if there is a corresponding `@counter` value).\n\n```ruby\nobj = Object.new\nobj = SimpleMock(obj)\nobj.expects(:hoge, true)\nobj.watch(:hoge)\nobj.hoge #=> true\n```\n\nAlso, to avoid overwriting methods defined via expects when watch is executed, we save the method names from expects as an array in `@expects`.\nIn watch, we look at `@expects` and avoid overwriting methods if they are already defined by expects.\nOtherwise, the return value information of the mock method would be lost when the watch method is executed.\n\nNext, let's consider the implementation of the new method. From the specification, SimpleMock is required to be a module,\nbut at the same time it is also required to have a new method that doesn't exist in modules.\nWe satisfy this by explicitly defining the class method new. At this point, we can satisfy the requirements by passing some object as an argument to the mock method and returning the return value, but since it's easier to handle mock objects with as few extra methods as possible,\nwe use Object.new as the argument to the mock method.",
  "answerCode": "module SimpleMock\n  def self.mock(obj)\n    obj.extend(SimpleMock)\n    obj\n  end\n\n  def self.new\n    obj = Object.new\n    mock(obj)\n  end\n\n  def expects(name, value)\n    define_singleton_method(name) do\n      @counter[name] += 1 if @counter&.key?(name)\n      value\n    end\n    @expects ||= []\n    @expects.push(name.to_sym)\n  end\n\n  def watch(name)\n    (@counter ||= {})[name] = 0\n\n    return if @expects&.include?(name.to_sym)\n\n    define_singleton_method(name) do\n      @counter[name] += 1\n    end\n  end\n\n  def called_times(name)\n    @counter[name]\n  end\nend\n",
  "testCode": "require 'minitest'\n\nclass TestSimpleMock < Minitest::Test\n  class ClassForMockTest\n    def hoge\n      'hoge'\n    end\n  end\n\n  def test_mock_initialize\n    obj = SimpleMock.new\n    assert_kind_of SimpleMock, obj\n  end\n\n  def test_mock_extend\n    obj = ClassForMockTest.new\n    SimpleMock.mock(obj)\n\n    assert_kind_of SimpleMock, obj\n  end\n\n  def test_mock_retuns_setted_value_when_instance\n    obj = SimpleMock.new\n    expected = SecureRandom.hex\n    obj.expects(:imitated_method, expected)\n\n    assert_equal obj.imitated_method, expected\n  end\n\n  def test_mock_returns_setted_value_when_extended\n    obj = ClassForMockTest.new\n    SimpleMock.mock(obj)\n    expected = SecureRandom.hex\n    obj.expects(:imitated_method, expected)\n\n    assert_equal obj.imitated_method, expected\n  end\n\n  def test_mock_counts_how_many_times_called_method\n    obj = SimpleMock.mock(ClassForMockTest.new)\n    obj.watch(:hoge)\n\n    obj.hoge\n    obj.hoge\n    obj.hoge\n\n    assert_equal 3, obj.called_times(:hoge)\n  end\n\n  def test_mock_counts_how_many_times_called_mocked_method\n    obj = SimpleMock.new\n    obj.expects(:imitated_method, true)\n    obj.watch(:imitated_method)\n\n    obj.imitated_method\n    obj.imitated_method\n\n    assert_equal 2, obj.called_times(:imitated_method)\n  end\n\n  def test_mock_returns_value_and_counts_how_many_times\n    obj = SimpleMock.new\n    obj.expects(:imitated_method, 'hoge')\n    obj.watch(:imitated_method)\n\n    assert_equal('hoge', obj.imitated_method)\n    assert_equal('hoge', obj.imitated_method)\n\n    assert_equal 2, obj.called_times(:imitated_method)\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend\n"
};

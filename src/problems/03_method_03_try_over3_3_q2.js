// Try Over3 3 Q2
export const problem = {
  "section": "03_method",
  "id": "03_try_over3_3_q2",
  "title": "Try Over3 3 Q2",
  "title_en": "Try Over3 3 Q2",
  "description": "高度なメタプログラミング技術の問題。method_missing、プロキシオブジェクト、const_missing、DSLの実装などを学びます。 (Q2)",
  "description_en": "Advanced metaprogramming techniques quiz. Learn about method_missing, proxy objects, const_missing, DSL implementation, etc. (Q2)",
  "detailedDescription": "以下要件を満たす TryOver3::A2Proxy クラスを作成してください。\n\n- TryOver3::A2Proxy は initialize に TryOver3::A2 のインスタンスを受け取り、それを @source に代入する\n- TryOver3::A2Proxy は、@sourceに定義されているメソッドが自分自身に定義されているように振る舞う",
  "detailedDescription_en": "Please create a TryOver3::A2Proxy class that meets the following requirements.\n\n- TryOver3::A2Proxy receives an instance of TryOver3::A2 in initialize and assigns it to @source\n- TryOver3::A2Proxy behaves as if methods defined in @source are defined in itself",
  "problemCode": "TryOver3 = Module.new\n\nclass TryOver3::A2\n  def initialize(name, value)\n    instance_variable_set(\"@#{name}\", value)\n    self.class.attr_accessor name.to_sym unless respond_to? name.to_sym\n  end\nend\n",
  "answerCode": "TryOver3 = Module.new\n\nclass TryOver3::A2\n  def initialize(name, value)\n    instance_variable_set(\"@#{name}\", value)\n    self.class.attr_accessor name.to_sym unless respond_to? name.to_sym\n  end\nend\n\nclass TryOver3::A2Proxy\n  def initialize(source)\n    @source = source\n  end\n\n  def method_missing(...)\n    @source.send(...)\n  end\n\n  def respond_to_missing?(name, include_all)\n    @source.respond_to?(name, include_all)\n  end\nend\n\n# Q3.\n# Module#remove_methodを利用するとメソッドを削除できます。これを使い、\n# 「boolean 以外が入っている場合には #{name}? メソッドが存在しないようにする」を実現します。\n# なお、メソッドを削除するメソッドはremove_methodの他にundef_methodも存在します。こちらでもテストはパスします。\n# remove_methodとundef_methodの違いが気になる方はドキュメントを読んでみてください。\n#\nmodule TryOver3::OriginalAccessor2\n  def self.included(mod)\n    mod.define_singleton_method :my_attr_accessor do |name|\n      define_method name do\n        @attr\n      end\n\n      define_method \"#{name}=\" do |value|\n        if [true, false].include?(value) && !respond_to?(\"#{name}?\")\n          self.class.define_method \"#{name}?\" do\n            @attr == true\n          end\n        elsif respond_to? \"#{name}?\"\n          mod.remove_method \"#{name}?\"\n        end\n        @attr = value\n      end\n    end\n  end\nend\n",
  "testCode": "require 'minitest'\nrequire 'minitest/mock'\n\ndef alpha_rand\n  (0...8).map { ('a'..'z').to_a[rand(26)] }.join\nend\n\nclass TestTryOver03Q1 < Minitest::Test\n  def test_q2_proxy_foo\n    source = TryOver3::A2.new('foo', 'foofoo')\n    assert_equal 'foofoo', TryOver3::A2Proxy.new(source).foo\n  end\n\n  def test_q2_proxy_hoge_writer\n    source = TryOver3::A2.new('foo', 'foo')\n    proxy = TryOver3::A2Proxy.new(source)\n    proxy.foo = 'foofoo'\n    assert_equal 'foofoo', proxy.foo\n  end\n\n  def test_q2_proxy_rand\n    name = alpha_rand\n    source = TryOver3::A2.new(name, 'foo')\n    assert_equal 'foo', TryOver3::A2Proxy.new(source).public_send(name)\n  end\n\n  def test_q2_proxy_respond_to_foo\n    source = TryOver3::A2.new('foo', 'foofoo')\n    assert_respond_to TryOver3::A2Proxy.new(source), :foo\n  end\n\n  def test_q2_proxy_methods_not_included_foo\n    source = TryOver3::A2.new('foo', 'foofoo')\n    refute_includes TryOver3::A2Proxy.new(source).methods, :foo\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend\n",
  "answerExplanation": "この問題は、動的プロキシパターンの実装を学ぶものです。プロキシオブジェクトが別のオブジェクトのメソッド呼び出しを透過的に転送する仕組みを作ります。\n\n実装のポイント：\n1. `method_missing`で全ての引数（`...`）を受け取り、そのまま`@source`に転送\n2. Ruby 2.7以降の`...`（三点リーダー）は、全ての引数（位置引数、キーワード引数、ブロック）を転送\n3. `respond_to_missing?`も実装し、`@source`の`respond_to?`結果をそのまま返す\n\n重要な違い（Q1との比較）：\n- Q1では`respond_to_missing?`がなくてもテストは通りましたが、Q2では必須\n- プロキシパターンでは、元のオブジェクトのメソッド存在確認も正確に転送する必要がある\n- これにより、プロキシオブジェクトが完全に透過的に動作する\n\n動的プロキシは、オブジェクトのメソッド呼び出しをインターセプトして、ロギング、キャッシング、遅延評価などの機能を追加する際に有用です。",
  "answerExplanation_en": "This quiz teaches implementing the dynamic proxy pattern, where a proxy object transparently forwards method calls to another object.\n\nKey implementation points:\n1. `method_missing` receives all arguments (`...`) and forwards them directly to `@source`\n2. The `...` (three dots) in Ruby 2.7+ forwards all arguments (positional, keyword, and block)\n3. Also implement `respond_to_missing?`, returning the result of `@source`'s `respond_to?`\n\nImportant difference (compared to Q1):\n- In Q1, `respond_to_missing?` was optional for tests to pass, but in Q2 it's required\n- In the proxy pattern, method existence checks from the original object must be accurately forwarded\n- This ensures the proxy object operates completely transparently\n\nDynamic proxies are useful for intercepting method calls to add functionality like logging, caching, or lazy evaluation."
};

// Hierarchy Q6
export const problem = {
  "section": "02_object_model",
  "id": "02_hierarchy_q6",
  "title": "Hierarchy Q6",
  "title_en": "Hierarchy Q6",
  "detailedDescription": "前提: M1モジュールは変更しないこと\n\n次の動作をする C6 class を実装する\n- M1Refinements は Q5 で実装したものをそのまま使う\n- C6.new.name が 'Refined M1' を返すように C6 に name メソッドを実装する",
  "detailedDescription_en": "Premise: Do not modify the M1 module.\n\nImplement C6 class that behaves as follows\n- M1Refinements uses the same implementation from Q5\n- Implement a name method in C6 so that C6.new.name returns 'Refined M1'",
  "problemCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M1Refinements\nend\n\nclass C6\n  include M1\n  using M1Refinements\nend\n",
  "answerCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M1Refinements\n  refine M1 do\n    def name\n      'Refined M1'\n    end\n  end\nend\n\nclass C6\n  include M1\n  using M1Refinements\n\n  def name\n    super\n  end\nend\n",
  "testCode": "require 'minitest'\n\n# M1 module definition (needed for refinements)\nmodule M1\n  def name\n    'M1'\n  end\nend\n\n# M1Refinements definition (needed for Q6)\nmodule M1Refinements\n  refine M1 do\n    def name\n      'Refined M1'\n    end\n  end\nend\n\nclass TestHierarchy < Minitest::Test\n  def test_c6_name\n    assert_equal \"Refined M1\", C6.new.name\n\n    C6.include(Module.new do\n      def name = \"other\"\n    end)\n    assert_equal \"other\", C6.new.name\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend\n",
  "answerExplanation": "この問題は、refinementsの効果範囲についてより深い理解を求めるものです。\n\n重要なポイント：\n1. `include M1`によって、C6はM1の`name`メソッドを継承する\n2. しかし、`using M1Refinements`の効果は、**using以降に定義されたメソッド内でのみ**有効\n3. そのため、`using`の後に`name`メソッドを定義し、その中で`super`を呼び出す必要がある\n\n解決策：\n- `using M1Refinements`の後に`name`メソッドを定義\n- `super`を使って親クラス（この場合はM1）の`name`メソッドを呼び出す\n- `using`以降のスコープ内なので、リファインされた'Refined M1'が返される\n\nもし`using`より前に`name`メソッドを定義していた場合、refinementは適用されず、元のM1の実装（'M1'）が呼び出されることになります。",
  "answerExplanation_en": "This challenge requires a deeper understanding of the scope of refinements.\n\nKey points:\n1. Through `include M1`, C6 inherits M1's `name` method\n2. However, the effect of `using M1Refinements` is **only valid within methods defined after using**\n3. Therefore, we need to define the `name` method after `using` and call `super` within it\n\nSolution:\n- Define the `name` method after `using M1Refinements`\n- Use `super` to call the parent class's (in this case M1's) `name` method\n- Since it's within the scope after `using`, the refined 'Refined M1' is returned\n\nIf the `name` method were defined before `using`, the refinement wouldn't be applied, and the original M1 implementation ('M1') would be called."
};

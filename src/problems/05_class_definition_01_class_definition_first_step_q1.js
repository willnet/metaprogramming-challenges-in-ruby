// Class Definition First Step Q1
export const problem = {
  "section": "05_class_definition",
  "id": "01_class_definition_first_step_q1",
  "title": "Class Definition First Step Q1",
  "title_en": "Class Definition First Step Q1",
  "description": "Rubyのクラス定義についての基本的な問題。無名クラス、メタプログラミング、スコープゲートなどを学びます。 (Q1)",
  "description_en": "Basic problems about Ruby class definition. Learn about anonymous classes, metaprogramming, scope gates, etc. (Q1)",
  "detailedDescription": "1. ExClassクラスのオブジェクトが2つあります。これらをJudgement.callに渡しています。\n   使えるようにしてください。helloメソッドの中身は何でも良いです。\n2. ExClassを継承したクラスを作成してください。ただし、そのクラスは定数がない無名のクラスだとします。\n3. 下のMetaClassに対し、次のように`meta_`というプレフィックスが属性名に自動でつき、ゲッターの戻り値の文字列にも'meta 'が自動でつくattr_accessorのようなメソッドであるmeta_attr_accessorを作ってください。セッターに文字列以外の引数がくることは考えないとします。\n\n使用例:\n\n```\nclass MetaClass\n  # meta_attr_accessor自体の定義は省略\n  meta_attr_accessor :hello\nend\nmeta = MetaClass.new\nmeta.meta_hello = 'world'\nmeta.meta_hello #=> 'meta world'\n```\n\n4. 次のようなExConfigクラスを作成してください。ただし、グローバル変数、クラス変数は使わないものとします。\n\n使用例:\n\n```\nExConfig.config = 'hello'\nExConfig.config #=> 'hello'\nex = ExConfig.new\nex.config #=> 'hello'\nex.config = 'world'\nExConfig.config #=> 'world'\n```\n\n5. ExOver#helloというメソッドがライブラリとして定義されているとします。ExOver#helloメソッドを実行したとき、helloメソッドの前にExOver#before、helloメソッドの後にExOver#afterを実行させるようにExOverを変更しましょう。\n\n6. 次の toplevellocal ローカル変数の中身を返す MyGreeting#say を実装してみてください。ただし、下のMyGreetingは編集しないものとします。toplevellocal ローカル変数の定義の下の行から編集してください。",
  "problemCode": "#    Judement.callはテスト側で定義するので実装は不要です。この状況でe2オブジェクト\"だけ\"helloメソッドを\n\nclass ExClass\nend\n\ne1 = ExClass.new\ne2 = ExClass.new\n\nJudgement.call(e1, e2)\n\n#    その無名クラスをそのままJudgement2.call の引数として渡してください(Judgement2.callはテスト側で定義するので実装は不要です)\n\n\n\nclass MetaClass\nend\n\n\n\nclass ExConfig\nend\n\n# ただしExOver#hello, ExOver#before, ExOver#afterの実装はそれぞれテスト側で定義しているので実装不要(変更不可)です。\n\n\nclass ExOver\nend\n\n#    ヒント: スコープゲートを乗り越える方法について書籍にありましたね\n\nclass MyGreeting\nend\n\ntoplevellocal = 'hi'",
  "detailedDescription_en": "1. There are two ExClass objects. These are passed to Judgement.call.\n   Make them usable. The content of the hello method can be anything.\n2. Create a class that inherits from ExClass. However, assume that the class is an anonymous class without constants.\n3. For the MetaClass below, create a meta_attr_accessor method that automatically adds the prefix `meta_` to attribute names and 'meta ' to getter return value strings like attr_accessor. Assume that setter arguments other than strings will not be considered.\n\nUsage example:\n\n```\nclass MetaClass\n  # Definition of meta_attr_accessor itself is omitted\n  meta_attr_accessor :hello\nend\nmeta = MetaClass.new\nmeta.meta_hello = 'world'\nmeta.meta_hello #=> 'meta world'\n```\n\n4. Create an ExConfig class as follows. However, do not use global variables or class variables.\n\nUsage example:\n\n```\nExConfig.config = 'hello'\nExConfig.config #=> 'hello'\nex = ExConfig.new\nex.config #=> 'hello'\nex.config = 'world'\nExConfig.config #=> 'world'\n```\n\n5. Assume that a method called ExOver#hello is defined as a library. When executing the ExOver#hello method, modify ExOver to execute ExOver#before before the hello method and ExOver#after after the hello method.\n\n6. Implement MyGreeting#say that returns the contents of the toplevellocal local variable below.However, do not edit the MyGreeting below. Edit from the line below the definition of the toplevellocal local variable.",
  "answerExplanation": "Q1. 問題の解説\ne2オブジェクトの特異メソッドとしてhelloを定義する練習です。特異メソッドは対象のオブジェクトだけが利用可能なメソッドです。",
  "answerExplanation_en": "Q1. Problem Explanation\nThis is practice for defining hello as a singleton method of the e2 object. Singleton methods are methods that can only be used by the target object.",
  "answerCode": "class ExClass\nend\n\ne1 = ExClass.new\ne2 = ExClass.new\n\ndef e2.hello\nend\n\nJudgement.call(e1, e2)",
  "testCode": "require 'minitest'\n\nclass Judgement\n  def self.call(e1, e2)\n    @e1 = e1\n    @e2 = e2\n  end\nend\n\nclass Judgement2\n  def self.call(klass)\n    @klass = klass\n  end\nend\n\nclass ExOver\n  attr_accessor :result\n\n  def initialize\n    self.result = ''\n  end\n\n  def before\n    result << 'before'\n  end\n\n  def hello\n    result << 'hello'\n  end\n\n  def after\n    result << 'after'\n  end\nend\n\nclass TestClassDefinitionFirstStep < Minitest::Test\ndef test_judgement\n    e1 = Judgement.instance_variable_get(:@e1)\n    e2 = Judgement.instance_variable_get(:@e2)\n    assert e1.is_a?(ExClass)\n    assert e2.is_a?(ExClass)\n    refute e1.respond_to?(:hello)\n    assert e2.respond_to?(:hello)\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
};

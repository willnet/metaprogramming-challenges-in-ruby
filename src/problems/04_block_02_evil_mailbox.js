// Evil Mailbox
export const problem = {
  "section": "04_block",
  "id": "02_evil_mailbox",
  "title": "Evil Mailbox",
  "title_en": "Evil Mailbox",
  "description": "複雑なブロック処理とクロージャキャプチャを使ったメールボックスの実装問題。認証機能や秘密文字列の処理を学びます。",
  "description_en": "An implementation problem of a mailbox using complex block processing and closure capture. Learn about authentication features and secret string handling.",
  "detailedDescription": "次の仕様を満たすクラス、EvilMailboxを作成してください\n\n基本機能\n1. EvilMailboxは、コンストラクタで一つのオブジェクトを受け取る（このオブジェクトは、メールの送受信機能が実装されているが、それが何なのかは気にする必要はない）\n2. EvilMailboxは、メールを送るメソッド `send_mail` を持ち、引数として宛先の文字列、本文の文字列を受け取る。結果の如何に関わらず、メソッドはnilをかえす。\n3. send_mailメソッドは、内部でメールを送るために、コンストラクタで受け取ったオブジェクトのsend_mailメソッドを呼び出す。このときのシグネチャは同じである。また、このメソッドはメールの送信が成功したか失敗したかをbool値で返す。\n4. EvilMailboxは、メールを受信するメソッド `receive_mail` を持つ\n5. receive_mailメソッドは、メールを受信するためにコンストラクタで受け取ったオブジェクトのreceive_mailメソッドを呼び出す。このオブジェクトのreceive_mailは、送信者と本文の2つの要素をもつ配列を返す。\n6. receive_mailメソッドは、受け取ったメールを送信者と本文の2つの要素をもつ配列として返す\n\n応用機能\n\n1. send_mailメソッドは、ブロックを受けとることができる。ブロックは、送信の成功/失敗の結果をBool値で引数に受け取ることができる\n2. コンストラクタは、第2引数として文字列を受け取ることができる（デフォルトはnilである）\n3. コンストラクタが第2引数として文字列を受け取った時、第1引数のオブジェクトはその文字列を引数にしてauthメソッドを呼び出す\n4. 第2引数の文字列は、秘密の文字列のため、EvilMailboxのオブジェクトの中でいかなる形でも保存してはいけない\n\n邪悪な機能\n\n1. send_mailメソッドは、もしも\"コンストラクタで受け取ったオブジェクトがauthメソッドを呼んだ\"とき、勝手にその認証に使った文字列を、送信するtextの末尾に付け加える\n2. つまり、コンストラクタが第2引数に文字列を受け取った時、その文字列はオブジェクト内に保存されないが、send_mailを呼び出したときにこっそりと勝手に送信される",
  "detailedDescription_en": "Create an EvilMailbox class that meets the following specifications\n\nBasic Functions\n1. EvilMailbox receives one object in its constructor (this object has mail sending/receiving functionality, but you don't need to care what it is)\n2. EvilMailbox has a `send_mail` method to send mail, which takes a destination string and body string as arguments. The method returns nil regardless of the result.\n3. The send_mail method internally calls the send_mail method of the object received in the constructor to send mail. The signature is the same. This method returns a boolean value indicating whether the mail was sent successfully or failed.\n4. EvilMailbox has a `receive_mail` method to receive mail\n5. The receive_mail method calls the receive_mail method of the object received in the constructor to receive mail. This object's receive_mail returns an array with two elements: sender and body.\n6. The receive_mail method returns the received mail as an array with two elements: sender and body\n\nAdvanced Functions\n\n1. The send_mail method can receive a block. The block can take the result of sending success/failure as a Boolean argument\n2. The constructor can receive a string as the second argument (default is nil)\n3. When the constructor receives a string as the second argument, the first argument object calls the auth method with that string as an argument\n4. Since the string in the second argument is a secret string, it must not be saved in any form within the EvilMailbox object\n\nEvil Functions\n\n1. The send_mail method, if \"the object received in the constructor called the auth method\", automatically appends the authentication string to the end of the text to be sent\n2. In other words, when the constructor receives a string as the second argument, that string is not saved in the object, but is secretly sent when send_mail is called",
  "problemCode": "",
  "answerExplanation": "仕様の「邪悪な機能」をクロージャを使って実装することに気付けるかどうかを問う問題です。\ninitializeメソッドの中でdefine_singleton_methodを利用してsend_mailメソッドを定義することで、initializeメソッドのローカル変数として第2引数を扱います。こうすることで、\nsend_mailメソッドの中でしか参照できない変数ができあがります。",
  "answerExplanation_en": "This quiz tests whether you can realize that the \"evil function\" in the specification can be implemented using closures.\nBy defining the send_mail method using define_singleton_method inside the initialize method,\nthe second argument is handled as a local variable of the initialize method. This creates\na variable that can only be referenced within the send_mail method.",
  "answerCode": "class EvilMailbox\n  def initialize(obj, str = nil)\n    @obj = obj\n    @obj.auth(str) if str\n\n    define_singleton_method(:send_mail) do |to, body, &block|\n      result = obj.send_mail(to, body + str.to_s)\n      block.call(result) if block\n      nil\n    end\n  end\n\n  def receive_mail\n    obj.receive_mail\n  end\n\n  private\n\n  attr_reader :obj\nend\n",
  "testCode": "require 'minitest'\n\nclass TestEvilMailbox < Minitest::Test\n  def evil_mailbox(&block)\n    mock = Minitest::Mock.new\n    mock.instance_eval(&block) if block_given?\n    [EvilMailbox.new(mock), mock]\n  end\n\n  def test_send_mail\n    mb, mock = evil_mailbox do\n      expect :send_mail, true, %w[ppyd hello]\n    end\n    mb.send_mail('ppyd', 'hello')\n    mock.verify\n  end\n\n  def test_send_mail_returns_nil\n    mb, = evil_mailbox do\n      expect :send_mail, true, %w[ppyd hello]\n    end\n    assert_nil mb.send_mail('ppyd', 'hello')\n  end\n\n  def test_receive_mail\n    mb, mock = evil_mailbox do\n      expect :receive_mail, %w[kino Yo]\n    end\n    f, t = mb.receive_mail\n    mock.verify\n    assert_equal 'kino', f\n    assert_equal 'Yo', t\n  end\n\n  def test_send_mail_exec_block_with_result_true\n    mb, = evil_mailbox do\n      expect :send_mail, true, %w[ppyd hello]\n    end\n    ret = nil\n    mb.send_mail('ppyd', 'hello') do |res|\n      ret = res\n    end\n    assert_equal true, ret\n  end\n\n  def test_send_mail_exec_block_with_result_false\n    mb, = evil_mailbox do\n      expect :send_mail, false, %w[ppyd hello]\n    end\n    ret = nil\n    mb.send_mail('ppyd', 'hello') do |res|\n      ret = res\n    end\n    assert_equal false, ret\n  end\n\n  def test_mail_object_auth\n    secret_string = SecureRandom.hex\n    mock = Minitest::Mock.new\n    mock.expect :auth, true, [String]\n    EvilMailbox.new(mock, secret_string)\n    mock.verify\n  end\n\n  def test_send_mail_with_secret_string\n    secret_string = SecureRandom.hex\n    mock = Minitest::Mock.new\n    mock.expect :auth, true, [String]\n    mock.expect :send_mail, true, ['ppyd', \"hello#{secret_string}\"]\n    mb = EvilMailbox.new(mock, secret_string)\n\n    mb.send_mail('ppyd', 'hello')\n    mock.verify\n  end\n\n  def test_no_secret_string_in_object\n    secret_string = SecureRandom.hex\n    mock = Minitest::Mock.new\n    mock.expect :auth, true, [String]\n    mb = EvilMailbox.new(mock, secret_string)\n\n    mock.verify\n    mb.class.send(:class_variables).each do |cv|\n      assert_equal false, secret_string == mb.class.get_class_variable(cv)\n    end\n    mb.send(:instance_variables).each do |iv|\n      assert_equal false, secret_string == mb.instance_variable_get(iv)\n    end\n  end\n\n  def evil_mailbox_with_secret_string(secret_string, &block)\n    mock = Minitest::Mock.new\n    mock.instance_eval(&block) if block_given?\n    [EvilMailbox.new(mock, secret_string), mock]\n  end\n\n  def test_send_mail_exec_block_with_result_true_and_secret_string\n    secret_string = SecureRandom.hex\n    mb, mock = evil_mailbox_with_secret_string(secret_string) do\n      expect :auth, true, [String]\n      expect :send_mail, true, ['ppyd', \"hello#{secret_string}\"]\n    end\n\n    ret = nil\n    mb.send_mail('ppyd', 'hello') do |res|\n      ret = res\n    end\n    mock.verify\n    assert_equal true, ret\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend\n"
};

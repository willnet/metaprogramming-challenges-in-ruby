// Try Over3 3 Q3
export const problem = {
  "section": "03_method",
  "id": "03_try_over3_3_q3",
  "title": "Try Over3 3 Q3",
  "title_en": "Try Over3 3 Q3",
  "description": "動的にメソッドを削除してboolean以外の値に対してpredicate methodを存在させないOriginalAccessor2を実装します。",
  "description_en": "Implement OriginalAccessor2 that dynamically removes methods so predicate methods don't exist for non-boolean values.",
  "detailedDescription": "DefineのQ3ではOriginalAccessor の my_attr_accessor で定義した getter/setter に boolean の値が入っている場合には #{name}? が定義されるようなモジュールを実装しました。今回は、そのモジュールに boolean 以外が入っている場合には #{name}? メソッドが存在しないようにする変更を加えてください。",
  "detailedDescription_en": "In Q3 of Define, we implemented a module where #{name}? methods are defined when boolean values are assigned to getter/setter defined by OriginalAccessor's my_attr_accessor. This time, modify the module so that the #{name}? method does not exist when non-boolean values are assigned.",
  "problemCode": "TryOver3 = Module.new\n\nmodule TryOver3::OriginalAccessor2\n  def self.included(mod)\n    mod.define_singleton_method :my_attr_accessor do |name|\n      define_method name do\n        @attr\n      end\n\n      define_method \"#{name}=\" do |value|\n        if [true, false].include?(value) && !respond_to?(\"#{name}?\")\n          self.class.define_method \"#{name}?\" do\n            @attr == true\n          end\n        end\n        @attr = value\n      end\n    end\n  end\nend\n",
  "answerExplanation": "Module#remove_methodを利用するとメソッドを削除できます。これを使い、「boolean 以外が入っている場合には #{name}? メソッドが存在しないようにする」を実現します。なお、メソッドを削除するメソッドはremove_methodの他にundef_methodも存在します。こちらでもテストはパスします。remove_methodとundef_methodの違いが気になる方はドキュメントを読んでみてください。",
  "answerExplanation_en": "You can remove methods using `Module#remove_method`. This is used to implement the requirement that \"#{name}? methods should not exist when non-boolean values are assigned\". Note that there is another method for removing methods: `undef_method`. The tests will also pass with `undef_method`. If you're curious about the difference between `remove_method` and `undef_method`, please read the documentation.",
  "answerCode": "TryOver3 = Module.new\n\nmodule TryOver3::OriginalAccessor2\n  def self.included(mod)\n    mod.define_singleton_method :my_attr_accessor do |name|\n      define_method name do\n        @attr\n      end\n\n      define_method \"#{name}=\" do |value|\n        if [true, false].include?(value)\n          unless respond_to?(\"#{name}?\")\n            self.class.define_method \"#{name}?\" do\n              @attr == true\n            end\n          end\n        else\n          if respond_to?(\"#{name}?\")\n            self.class.send(:remove_method, \"#{name}?\")\n          end\n        end\n        @attr = value\n      end\n    end\n  end\nend\n",
  "testCode": "require 'minitest'\n\nclass TestTryOver03Q3 < Minitest::Test\n  def test_q3_original_accessor_boolean_method\n    instance = orignal_accessor_included_instance\n    instance.hoge = true\n    assert_equal(true, instance.hoge?)\n    instance.hoge = \"hoge\"\n    assert_raises(NoMethodError) { instance.hoge? }\n    refute_includes(instance.methods, :hoge?)\n  end\n\n  def test_q3_original_accessor_boolean_method_reverse\n    instance = orignal_accessor_included_instance\n    instance.hoge = \"hoge\"\n    assert_raises(NoMethodError) { instance.hoge? }\n    refute_includes(instance.methods, :hoge?)\n    instance.hoge = true\n    assert_equal(true, instance.hoge?)\n  end\n\n  def test_q3_original_accessor_false_value\n    instance = orignal_accessor_included_instance\n    instance.hoge = false\n    assert_equal(false, instance.hoge?)\n    instance.hoge = 0\n    assert_raises(NoMethodError) { instance.hoge? }\n    refute_includes(instance.methods, :hoge?)\n  end\n\n  private\n\n  def orignal_accessor_included_instance\n    Class.new do\n      include TryOver3::OriginalAccessor2\n      my_attr_accessor :hoge\n    end.new\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
};

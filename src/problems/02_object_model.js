export const objectModelProblems = [
  {
    "section": "02_object_model",
    "id": "01_hoge",
    "title": "Hoge",
    "description": "Rubyのオブジェクトモデルについての理解を深める問題。クラスとインスタンスの関係、メソッド探索の仕組みなどを学びます。",
    "problemCode": "# Q1.\n# Hogeクラスは次の仕様を持つ\n# \"hoge\" という文字列の定数Hogeを持つ\n# \"hoge\" という文字列を返すhogehogeメソッドを持つ\n# HogeクラスのスーパークラスはStringである\n# 自身が\"hoge\"という文字列である時（HogeクラスはStringがスーパークラスなので、当然自身は文字列である）、trueを返すhoge?メソッドが定義されている\n\nclass Hoge\nend\n\n# Q2.\n# 次に挙げるクラスのいかなるインスタンスからも、hogeメソッドが呼び出せるようにする\n# それらのhogeメソッドは、全て\"hoge\"という文字列を返す\n# - String\n# - Integer\n# - Numeric\n# - Class\n# - Hash\n# - TrueClass",
    "answerCode": "# Q1. 問題の解説\n#\n# ほぼ特筆するべきところがないですが、hoge?メソッドの実装は少し悩むかもしれません。\n# 自身を参照するにはselfを使います。\n#\nclass Hoge < String\n  Hoge = 'hoge'\n\n  def hogehoge\n    'hoge'\n  end\n\n  def hoge?\n    self == 'hoge'\n  end\nend\n\n# Q2. 問題の解説\n#\n# 回答例ではObjectクラスにhogeメソッドを定義しました。仕様としてあげられているクラスはすべて\n# Objectクラスのサブクラスなので、Objectクラスのインスタンスメソッドとしてhogeを定義すると仕様を満たせます。\n# Objectクラスではなく、仕様としてあげられていた各クラス(String, Integer, Numeric, Class, Hash, TrueClass)\n# に対してそれぞれ個別にhogeメソッドを定義しても問題ありません。\nclass Object\n  def hoge\n    'hoge'\n  end\nend",
    "testCode": "require 'minitest'\n\nclass TestHoge < Minitest::Test\n  def test_hoge_in_string\n    assert_equal \"hoge\",\"hoge\".hoge\n  end\n\n  def test_hoge_in_integer\n    assert_equal \"hoge\", 1.hoge\n  end\n\n  def test_hoge_in_numeric\n    assert_equal \"hoge\", (1.1).hoge\n  end\n\n  def test_hoge_in_class\n    assert_equal \"hoge\", Class.hoge\n  end\n\n  def test_hoge_in_hash\n    assert_equal \"hoge\", ({hoge: :foo}).hoge\n  end\n\n  def test_hoge_in_true_class\n    assert_equal \"hoge\", true.hoge\n  end\n\n  def test_hoge_const\n    assert_equal \"hoge\", Hoge::Hoge\n  end\n\n  def test_hogehoge_method_exists_in_hoge_class\n    assert Hoge.instance_methods(false).include?(:hogehoge)\n  end\n\n  def test_hogehoge_method_returns_hoge\n    assert_equal \"hoge\", Hoge.new.hogehoge\n  end\n\n  def test_hoge_super_class_is_string\n    assert_equal String, Hoge.superclass\n  end\n\n  def test_ask_hoge_myself_true\n    assert Hoge.new(\"hoge\").hoge?\n  end\n\n  def test_ask_hoge_myself_false\n    refute Hoge.new(\"foo\").hoge?\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "02_object_model",
    "id": "02_hierarchy",
    "title": "Hierarchy",
    "description": "Rubyのクラス階層とモジュールの仕組みについての問題。祖先チェーン、メソッド探索、refinementなどを学びます。",
    "problemCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\n\n# Q1.\n# 次の動作をする C1 class を実装する\n# - C1.ancestors.first(2) が [C1, M1] となる\n# - C1.new.name が 'C1' を返す\nclass C1\n  def name\n    'C1'\n  end\nend\n\n\n# Q2.\n# 次の動作をする C2 class を実装する\n# - C2.ancestors.first(2) が [M1, C2] となる\n# - C2.new.name が 'M1' を返す\nclass C2\n  def name\n    'C2'\n  end\nend\n\n\n# Q3.\n# 次の動作をする C3 class, MySuperClass class を実装する\n# - C3.ancestors.first(6) が [M1, C3, M2, M3, MySuperClass, M4] となる\n# - C3.new.name が 'M1' を返す\nclass C3\n  def name\n    'C3'\n  end\nend\n\n\n# Q4.\n# 次の動作をする C4 class のメソッド increment を実装する\n# - increment メソッドを呼ぶと value が +1 される\n# - また、increment メソッドは value を文字列にしたものを返す\n#   c4 = C4.new\n#   c4.increment # => \"1\"\n#   c4.increment # => \"2\"\n#   c4.increment # => \"3\"\n# - 定義済みのメソッド (value, value=) は private のままとなっている\n# - incrementメソッド内で value, value=を利用する\nclass C4\n  private\n\n  attr_accessor :value\nend\n\n# Q5.\n# 次の動作をする M1Refinements module を実装する\n# - M1Refinements は M1 の name インスタンスメソッドをリファインし,\n#   リファインされた name メソッドは \"Refined M1\" を返す\n# - C5.new.another_name が文字列 \"M1\" を返す\n# - C5.new.other_name が文字列 \"Refined M1\" を返す\nmodule M1Refinements\nend\n\nclass C5\n  include M1\n\n  def another_name\n    name\n  end\n\n  using M1Refinements\n\n  def other_name\n    name\n  end\nend\n\n\n# Q6.\n# 次の動作をする C6 class を実装する\n# - M1Refinements は Q5 で実装したものをそのまま使う\n# - C6.new.name が 'Refined M1' を返すように C6 に name メソッドを実装する\nclass C6\n  include M1\n  using M1Refinements\nend",
    "answerCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\n\n# Q1. 問題の解説\n#\n# M1をC1にincludeすると、継承ツリーはC1の次にM1が位置することになり、仕様を満たせます。\n#\nclass C1\n  include M1\n\n  def name\n    'C1'\n  end\nend\n\n\n# Q2. 問題の解説\n#\n# M1をC2にprependすると、継承ツリーはM2の次にC2が位置することになり、仕様を満たせます。\n#\nclass C2\n  prepend M1\n\n  def name\n    'C2'\n  end\nend\n\n\n# Q3. 問題の解説\n#\n# モジュールを複数includeしたり、スーパークラスを明示的に定義したときの\n# 継承ツリーがどうなるかの理解を問う問題です\n#\nclass MySuperClass\n  include M4\nend\n\nclass C3 < MySuperClass\n  prepend M1\n  include M3\n  include M2\n\n  def name\n    'C3'\n  end\nend\n\n\n# Q4. 問題の解説\n#\n# privateメソッドとして定義していると、レシーバを明示的に指定したメソッド呼び出しができません。\n# しかしこれには例外があり、レシーバがselfであれば問題ありません。\n# この仕様はRuby2.7からのものであり、2.7未満はセッターメソッド(=が末尾についているもの)のみがselfをつけて呼び出し可能でした。\nclass C4\n  def increment\n    self.value ||= 0\n    self.value += 1\n    value.to_s\n  end\n  private\n\n  attr_accessor :value\nend\n\n# Q5. 問題の解説\n#\n# refinementsの練習問題です。\n# refineしたメソッドの影響範囲はusingがクラス内であれば、そのusingしたクラス内でのみ、かつusing以降の行です。\nmodule M1Refinements\n  refine M1 do\n    def name\n      'Refined M1'\n    end\n  end\nend\n\nclass C5\n  include M1\n\n  def another_name\n    name\n  end\n\n  using M1Refinements\n\n  def other_name\n    name\n  end\nend\n\n\n# Q6. 問題の解説\n#\n# Q5の解説でも書いたように、refineしたメソッドの影響範囲はusingがクラス内であれば、そのusingしたクラス内でのみ、かつusing以降の行です。\n# なので、問題として用意したコードのままだとなにもrefineされず、もともとのC6#nameは'M1'を返します。\n# using以降の行でM1#nameを呼び出すC6#nameを定義するとrefineした実装が呼び出されます。\n#\nclass C6\n  include M1\n  using M1Refinements\n\n  def name\n    super\n  end\nend",
    "testCode": "require 'minitest'\n\nclass TestHierarchy < Minitest::Test\n  def test_c1_ancestors\n    assert_equal [C1, M1], C1.ancestors.first(2)\n  end\n\n  def test_c1_name\n    assert_equal 'C1', C1.new.name\n  end\n\n  def test_c2_ancestors\n    assert_equal [M1, C2], C2.ancestors.first(2)\n  end\n\n  def test_c2_name\n    assert_equal 'M1', C2.new.name\n  end\n\n  def test_c3_ancestors\n    assert_equal [M1, C3, M2, M3, MySuperClass, M4], C3.ancestors.first(6)\n  end\n\n  def test_c3_name\n    assert_equal 'M1', C3.new.name\n  end\n\n  def test_c3_super_class\n    assert MySuperClass.kind_of?(Class)\n  end\n\n  def test_c4_increment\n    c4 = C4.new\n    assert_equal \"1\", c4.increment\n    assert_equal \"2\", c4.increment\n    assert_equal \"3\", c4.increment\n  end\n\n  def test_c4_value_called\n    c4 = C4.new\n    c4.singleton_class.class_eval do\n      private\n\n      def value=(x)\n        @called_setter = true\n        @value = x\n      end\n\n      def value\n        @called_getter = true\n        if defined?(@value)\n          @value\n        else\n          nil\n        end\n      end\n    end\n    c4.instance_variable_set(:\"@called_setter\", nil)\n    c4.instance_variable_set(:\"@called_getter\", nil)\n\n    assert_equal \"1\", c4.increment\n    assert c4.instance_variable_get(:\"@called_setter\")\n    assert c4.instance_variable_get(:\"@called_getter\")\n  end\n\n  def test_c4_value_methods\n    assert C4.private_instance_methods.include?(:value)\n    assert C4.private_instance_methods.include?(:value=)\n  end\n\n  def test_c5_another_name\n    assert_equal \"M1\", C5.new.another_name\n  end\n\n  def test_c5_other_name\n    assert_equal \"Refined M1\", C5.new.other_name\n  end\n\n  def test_c6_name\n    assert_equal \"Refined M1\", C6.new.name\n\n    C6.include(Module.new do\n      def name = \"other\"\n    end)\n    assert_equal \"other\", C6.new.name\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  }
];
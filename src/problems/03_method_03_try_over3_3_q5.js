// Try Over3 3 Q5
export const problem = {
  "section": "03_method",
  "id": "03_try_over3_3_q5",
  "title": "Try Over3 3 Q5",
  "title_en": "Try Over3 3 Q5",
  "description": "後方互換性を保ちながらTaskHelperを拡張してメソッド呼び出しとクラス生成の両方をサポートします。",
  "description_en": "Extend TaskHelper while maintaining backward compatibility to support both method calls and class generation.",
  "detailedDescription": "TryOver3::TaskHelper という include すると task というクラスマクロが与えられるモジュールがあります。TryOver3::TaskHelper は include することで以下のような使い方ができます。\n\n```\n> TryOver3::A5Task::Foo.run\nstart 2020-01-07 18:03:10 +0900\nfinish 2020-01-07 18:03:10 +0900\n#=> \"foo\"\n```\n\nTryOver3::TaskHelper では TryOver3::A5Task::Foo のように Foo クラスを作らず、TryOver3::A5Task.foo のようにクラスメソッドとして task で定義された名前のクラスメソッドでブロックを実行するように変更したいです。\n\n現在 TryOver3::TaskHelper のユーザには TryOver3::A5Task::Foo.run のように生成されたクラスを使って実行しているユーザが存在します。今回変更を加えても、その人たちにはこれまで通り生成されたクラスのrunメソッドでタスクを実行できるようにしておいて、warning だけだしておくようにしたいです。\n\nTryOver3::TaskHelper を修正してそれを実現してください。なお、その際、クラスは実行されない限り生成されないものとします。\n\n\n変更後想定する使い方: メソッドを使ったケース\n\n```\n> TryOver3::A5Task.foo\nstart 2020-01-07 18:03:10 +0900\nfinish 2020-01-07 18:03:10 +0900\n#=> \"foo\"\n```\n\nクラスのrunメソッドを使ったケース\n\n```\n> TryOver3::A5Task::Foo.run\nWarning: TryOver3::A5Task::Foo.run is deprecated\nstart 2020-01-07 18:03:10 +0900\nfinish 2020-01-07 18:03:10 +0900\n# => \"foo\"\n```",
  "detailedDescription_en": "There is a module called TryOver3::TaskHelper that provides a class macro called task when included. TryOver3::TaskHelper can be used as follows when included:\n\n```\n> TryOver3::A5Task::Foo.run\nstart 2020-01-07 18:03:10 +0900\nfinish 2020-01-07 18:03:10 +0900\n#=> \"foo\"\n```\n\nWith TryOver3::TaskHelper, instead of creating a Foo class like TryOver3::A5Task::Foo, we want to change it to execute the block with a class method of the name defined by task, like TryOver3::A5Task.foo.\n\nCurrently, some users of TryOver3::TaskHelper are executing using the generated class like TryOver3::A5Task::Foo.run. Even with this change, we want to allow them to continue executing tasks with the run method of the generated class as before, and just output a warning.\n\nPlease modify TryOver3::TaskHelper to achieve this. Note that classes should not be generated unless they are executed.\n\n\nExpected usage after change: Case using method\n\n```\n> TryOver3::A5Task.foo\nstart 2020-01-07 18:03:10 +0900\nfinish 2020-01-07 18:03:10 +0900\n#=> \"foo\"\n```\n\nCase using class run method\n\n```\n> TryOver3::A5Task::Foo.run\nWarning: TryOver3::A5Task::Foo.run is deprecated\nstart 2020-01-07 18:03:10 +0900\nfinish 2020-01-07 18:03:10 +0900\n# => \"foo\"\n```",
  "problemCode": "TryOver3 = Module.new\n\nmodule TryOver3::TaskHelper\n  def self.included(klass)\n    klass.define_singleton_method :task do |name, &task_block|\n      new_klass = Class.new do\n        define_singleton_method :run do\n          puts \"start #{Time.now}\"\n          block_return = task_block.call\n          puts \"finish #{Time.now}\"\n          block_return\n        end\n      end\n      new_klass_name = name.to_s.split(\"_\").map{ |w| w[0] = w[0].upcase; w }.join\n      const_set(new_klass_name, new_klass)\n    end\n  end\nend\n\nclass TryOver3::A5Task\n  include TryOver3::TaskHelper\n\n  task :foo do\n    \"foo\"\n  end\nend\n",
  "answerExplanation": "これまで解いてきた問題の解法と、仕様を読み解く知識が問われる問題です。2種類の書き方で同一の処理を行うが、そのうち1つは追加でdeprecation warningを出します。メソッドの実態はdefine_singleton_methodで定義し、もう1つはQ4と同様にconst_misisingを使い、runメソッド実行時にsendでもともとの定義を呼びだします。\n\ntaskで定義されていないタスク名を定数として参照したときは既存のconst_missingの処理を継続させたいのでsuperを実行しています。",
  "answerExplanation_en": "This is a problem that tests the knowledge of solutions to problems solved so far and the ability to understand specifications. It performs the same processing with two different ways of writing, but one of them additionally outputs a deprecation warning. The actual method is defined with define_singleton_method, and the other uses const_missing like Q4, calling the original definition with send when the run method is executed.\n\nWhen a task name not defined by task is referenced as a constant, we want to continue the existing const_missing processing, so we execute super.",
  "answerCode": "module TryOver3\nend\n\nmodule TryOver3::TaskHelper\n  def self.included(klass)\n    klass.define_singleton_method :task do |name, &task_block|\n      define_singleton_method name do\n        puts \"start #{Time.now}\"\n        block_return = task_block.call\n        puts \"finish #{Time.now}\"\n        block_return\n      end\n\n      define_singleton_method(:const_missing) do |const|\n        super(const) unless klass.respond_to?(const.downcase)\n\n        obj = Object.new\n        obj.define_singleton_method :run do\n          warn \"Warning: TryOver3::A5Task::#{const}.run is deprecated\"\n          klass.send name\n        end\n        obj\n      end\n    end\n  end\nend\n\nclass TryOver3::A5Task\n  include TryOver3::TaskHelper\n\n  task :foo do\n    \"foo\"\n  end\nend\n",
  "testCode": "require 'minitest'\n\nclass TestTryOver03Q5 < Minitest::Test\n  def test_q5_task_helper_call_method\n    assert_equal(\"foo\", TryOver3::A5Task.foo)\n  end\n\n  def test_q5_task_helper_not_exists_class\n    refute_includes TryOver3::A5Task.constants, :Foo\n  end\n\n  def test_q5_task_helper_call_class\n    assert_equal(\"foo\", TryOver3::A5Task::Foo.run)\n  end\n\n  def test_q5_task_helper_call_class_with_warn\n    original_stderr = $stderr\n    $stderr = StringIO.new\n    \n    TryOver3::A5Task::Foo.run\n    warning_output = $stderr.string\n    \n    assert_match \"Warning: TryOver3::A5Task::Foo.run is deprecated\", warning_output\n  ensure\n    $stderr = original_stderr\n  end\n\n  def test_q5_error_when_called_not_defined_task_class\n    assert_raises(NameError) { TryOver3::A5Task::Bar.run }\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
};

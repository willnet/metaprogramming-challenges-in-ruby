// Hierarchy Q4
export const problem = {
  "section": "02_object_model",
  "id": "02_hierarchy_q4",
  "title": "Hierarchy Q4",
  "title_en": "Hierarchy Q4",
  "description": "Rubyのクラス階層とモジュールの仕組みについての問題。祖先チェーン、メソッド探索、refinementなどを学びます。 (Q4)",
  "description_en": "A problem about Ruby's class hierarchy and module mechanisms. Learn about ancestor chains, method lookup, refinements, etc. (Q4)",
  "detailedDescription": "Q4.\n次の動作をする C4 class のメソッド increment を実装する\n- increment メソッドを呼ぶと value が +1 される\n- また、increment メソッドは value を文字列にしたものを返す\n  c4 = C4.new\n  c4.increment # => \"1\"\n  c4.increment # => \"2\"\n  c4.increment # => \"3\"\n- 定義済みのメソッド (value, value=) は private のままとなっている\n- incrementメソッド内で value, value=を利用する",
  "detailedDescription_en": "Q4.\nImplement the increment method of C4 class that behaves as follows\n- Calling the increment method increases value by +1\n- The increment method returns the value as a string\n  c4 = C4.new\n  c4.increment # => \"1\"\n  c4.increment # => \"2\"\n  c4.increment # => \"3\"\n- The predefined methods (value, value=) remain private\n- Use value, value= within the increment method",
  "problemCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\nclass C4\n  private\n\n  attr_accessor :value\nend",
  "answerCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\n# Q4. 問題の解説\n#\n# privateメソッドとして定義していると、レシーバを明示的に指定したメソッド呼び出しができません。\n# しかしこれには例外があり、レシーバがselfであれば問題ありません。\n# この仕様はRuby2.7からのものであり、2.7未満はセッターメソッド(=が末尾についているもの)のみがselfをつけて呼び出し可能でした。\nclass C4\n  def increment\n    self.value ||= 0\n    self.value += 1\n    value.to_s\n  end\n  private\n\n  attr_accessor :value\nend",
  "testCode": "require 'minitest'\n\nclass TestHierarchy < Minitest::Test\ndef test_c4_increment\n    c4 = C4.new\n    assert_equal \"1\", c4.increment\n    assert_equal \"2\", c4.increment\n    assert_equal \"3\", c4.increment\n  end\n\ndef test_c4_value_called\n    c4 = C4.new\n    c4.singleton_class.class_eval do\n      private\n\n      def value=(x)\n        @called_setter = true\n        @value = x\n      end\n\n      def value\n        @called_getter = true\n        if defined?(@value)\n          @value\n        else\n          nil\n        end\n      end\n    end\n    c4.instance_variable_set(:\"@called_setter\", nil)\n    c4.instance_variable_set(:\"@called_getter\", nil)\n\n    assert_equal \"1\", c4.increment\n    assert c4.instance_variable_get(:\"@called_setter\")\n    assert c4.instance_variable_get(:\"@called_getter\")\n  end\n\ndef test_c4_value_methods\n    assert C4.private_instance_methods.include?(:value)\n    assert C4.private_instance_methods.include?(:value=)\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend",
  "answerExplanation": "",
  "answerExplanation_en": ""
};

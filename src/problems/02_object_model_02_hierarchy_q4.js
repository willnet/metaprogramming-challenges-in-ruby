// Hierarchy Q4
export const problem = {
  "section": "02_object_model",
  "id": "02_hierarchy_q4",
  "title": "Hierarchy Q4",
  "title_en": "Hierarchy Q4",
  "description": "Rubyのクラス階層とモジュールの仕組みについての問題。祖先チェーン、メソッド探索、refinementなどを学びます。 (Q4)",
  "description_en": "A problem about Ruby's class hierarchy and module mechanisms. Learn about ancestor chains, method lookup, refinements, etc. (Q4)",
  "detailedDescription": "次の動作をする C4 class のメソッド increment を実装する\n- increment メソッドを呼ぶと value が +1 される\n- また、increment メソッドは value を文字列にしたものを返す\n  c4 = C4.new\n  c4.increment # => \"1\"\n  c4.increment # => \"2\"\n  c4.increment # => \"3\"\n- 定義済みのメソッド (value, value=) は private のままとなっている\n- incrementメソッド内で value, value=を利用する",
  "detailedDescription_en": "Implement the increment method of C4 class that behaves as follows\n- Calling the increment method increases value by +1\n- The increment method returns the value as a string\n  c4 = C4.new\n  c4.increment # => \"1\"\n  c4.increment # => \"2\"\n  c4.increment # => \"3\"\n- The predefined methods (value, value=) remain private\n- Use value, value= within the increment method",
  "problemCode": "class C4\n  private\n\n  attr_accessor :value\nend\n",
  "answerCode": "class C4\n  def increment\n    self.value ||= 0\n    self.value += 1\n    value.to_s\n  end\n\n  private\n\n  attr_accessor :value\nend\n",
  "testCode": "require 'minitest'\n\nclass TestHierarchy < Minitest::Test\n  def test_c4_increment\n    c4 = C4.new\n    assert_equal '1', c4.increment\n    assert_equal '2', c4.increment\n    assert_equal '3', c4.increment\n  end\n\n  def test_c4_value_called\n    c4 = C4.new\n    c4.singleton_class.class_eval do\n      private\n\n      def value=(x)\n        @called_setter = true\n        @value = x\n      end\n\n      def value\n        @called_getter = true\n        return unless defined?(@value)\n\n        @value\n      end\n    end\n    c4.instance_variable_set(:\"@called_setter\", nil)\n    c4.instance_variable_set(:\"@called_getter\", nil)\n\n    assert_equal '1', c4.increment\n    assert c4.instance_variable_get(:\"@called_setter\")\n    assert c4.instance_variable_get(:\"@called_getter\")\n  end\n\n  def test_c4_value_methods\n    assert C4.private_instance_methods.include?(:value)\n    assert C4.private_instance_methods.include?(:value=)\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend\n",
  "answerExplanation": "この問題は、Rubyのprivateメソッドの呼び出しルールに関する理解を問うものです。\n\n重要なポイント：\n1. privateメソッドは通常、レシーバを明示的に指定して呼び出すことができません\n2. ただし、`self`をレシーバとする場合は例外です（Ruby 2.7以降）\n3. Ruby 2.7より前では、セッターメソッド（`=`で終わるメソッド）のみ`self`付きで呼び出し可能でした\n\n解答では：\n- `self.value ||= 0`で初期値を設定（nilの場合は0）\n- `self.value += 1`で値をインクリメント（セッターメソッドなので`self`が必須）\n- `value.to_s`で文字列に変換して返す（ゲッターメソッドは`self`なしでも可）\n\n`attr_accessor :value`はprivate以下で定義されているため、`value`と`value=`の両方がprivateメソッドになります。",
  "answerExplanation_en": "This problem tests understanding of Ruby's private method calling rules.\n\nKey points:\n1. Private methods normally cannot be called with an explicit receiver\n2. However, using `self` as the receiver is an exception (Ruby 2.7 and later)\n3. Before Ruby 2.7, only setter methods (ending with `=`) could be called with `self`\n\nIn the solution:\n- `self.value ||= 0` sets the initial value (0 if nil)\n- `self.value += 1` increments the value (`self` is required for setter methods)\n- `value.to_s` converts to string and returns it (getter methods can be called without `self`)\n\nSince `attr_accessor :value` is defined under private, both `value` and `value=` become private methods."
};

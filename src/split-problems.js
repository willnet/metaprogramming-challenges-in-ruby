// 分割された問題データ
export const splitProblems = [
  {
    "section": "00_setup",
    "id": "01_try_out",
    "title": "TryOut",
    "description": "基本的なクラス実装の練習。コンストラクタ、メソッド、アクセサなどの基本的な機能を実装します。",
    "problemCode": "class TryOut\n  # このクラスの仕様\n  # コンストラクタは、2つまたは3つの引数を受け付ける。引数はそれぞれ、ファーストネーム、ミドルネーム、ラストネームの順で、ミドルネームは省略が可能。\n  # full_nameメソッドを持つ。これは、ファーストネーム、ミドルネーム、ラストネームを半角スペース1つで結合した文字列を返す。ただし、ミドルネームが省略されている場合に、ファーストネームとラストネームの間には1つのスペースしか置かない\n  # first_name=メソッドを持つ。これは、引数の内容でファーストネームを書き換える。\n  # upcase_full_nameメソッドを持つ。これは、full_nameメソッドの結果をすべて大文字で返す。このメソッドは副作用を持たない。\n  # upcase_full_name! メソッドを持つ。これは、upcase_full_nameの副作用を持つバージョンで、ファーストネーム、ミドルネーム、ラストネームをすべて大文字に変え、オブジェクトはその状態を記憶する\nend",
    "answerCode": "# 問題の解説\n#\n# ミドルネームが渡されないことがある、というのをどう扱うかがこの問題のポイントです。\n# `def initialize(first_name, middle_name = nil, last_name)`のようにメソッドを定義することで\n# 簡潔に仕様を満たすことができます。\n# あとはスペースで各要素を区切るやり方としてArray#joinを使っているのもポイントです。\n# これ以外にも複数の解法があります。この回答通りになっていなくても問題ありません。\nclass TryOut\n  attr_writer :first_name\n\n  def initialize(first_name, middle_name = nil, last_name)\n    @first_name = first_name\n    @middle_name = middle_name\n    @last_name = last_name\n  end\n\n  def full_name\n    [@first_name, @middle_name, @last_name].compact.join(' ')\n  end\n\n  def upcase_full_name\n    full_name.upcase\n  end\n\n  def upcase_full_name!\n    @first_name.upcase!\n    @middle_name&.upcase!\n    @last_name.upcase!\n    full_name\n  end\nend",
    "testCode": "require 'minitest'\n\nclass TryOutTest < Minitest::Test\n  def test_first_last_name\n    target = TryOut.new(\"John\", \"Wick\")\n    assert_equal \"John Wick\", target.full_name\n  end\n\n  def test_first_middle_last_name\n    target = TryOut.new(\"Keanu\", \"Charies\",  \"Reeves\")\n    assert_equal \"Keanu Charies Reeves\", target.full_name\n  end\n\n  def test_first_name_accessor\n    target = TryOut.new(\"Henrik\", \"Vanger\")\n    target.first_name = \"Martin\"\n    assert_equal \"Martin Vanger\", target.full_name\n  end\n\n  def test_upcase_full_name\n    target = TryOut.new(\"Arthur\", \"Fleck\")\n    assert_equal \"ARTHUR FLECK\", target.upcase_full_name\n  end\n\n  def test_upcase_full_name_no_side_effect\n    target = TryOut.new(\"Lorraine\", \"Broughton\")\n    target.upcase_full_name\n    assert_equal \"Lorraine Broughton\", target.full_name\n  end\n\n  def test_upcase_full_name_bang\n    target = TryOut.new(\"Earl\", \"Stone\")\n    assert_equal \"EARL STONE\", target.upcase_full_name!\n  end\n\n  def test_upcase_full_name_bang_has_side_effect\n    target = TryOut.new(\"Murphy\", \"McManus\")\n    target.upcase_full_name!\n    assert_equal \"MURPHY MCMANUS\", target.full_name\n  end\n\n  def test_too_few_arguments\n    assert_raises (ArgumentError) {TryOut.new(\"John\")}\n  end\n\n  def test_too_many_arguments\n    assert_raises (ArgumentError) {TryOut.new(\"John\", \"Milton\", \"Cage\", \"Jr\")}\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "02_object_model",
    "id": "01_hoge_q1",
    "title": "Hoge Q1",
    "description": "Rubyのオブジェクトモデルについての理解を深める問題。クラスとインスタンスの関係、メソッド探索の仕組みなどを学びます。 (Q1)",
    "problemCode": "# Q1.\n# Hogeクラスは次の仕様を持つ\n# \"hoge\" という文字列の定数Hogeを持つ\n# \"hoge\" という文字列を返すhogehogeメソッドを持つ\n# HogeクラスのスーパークラスはStringである\n# 自身が\"hoge\"という文字列である時（HogeクラスはStringがスーパークラスなので、当然自身は文字列である）、trueを返すhoge?メソッドが定義されている\n\nclass Hoge\nend",
    "answerCode": "# Q1. 問題の解説\n#\n# ほぼ特筆するべきところがないですが、hoge?メソッドの実装は少し悩むかもしれません。\n# 自身を参照するにはselfを使います。\n#\nclass Hoge < String\n  Hoge = 'hoge'\n\n  def hogehoge\n    'hoge'\n  end\n\n  def hoge?\n    self == 'hoge'\n  end\nend",
    "testCode": "require 'minitest'\n\nclass TestHoge < Minitest::Test\ndef test_hoge_in_string\n    assert_equal \"hoge\",\"hoge\".hoge\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "02_object_model",
    "id": "01_hoge_q2",
    "title": "Hoge Q2",
    "description": "Rubyのオブジェクトモデルについての理解を深める問題。クラスとインスタンスの関係、メソッド探索の仕組みなどを学びます。 (Q2)",
    "problemCode": "# Q2.\n# 次に挙げるクラスのいかなるインスタンスからも、hogeメソッドが呼び出せるようにする\n# それらのhogeメソッドは、全て\"hoge\"という文字列を返す\n# - String\n# - Integer\n# - Numeric\n# - Class\n# - Hash\n# - TrueClass",
    "answerCode": "# Q2. 問題の解説\n#\n# 回答例ではObjectクラスにhogeメソッドを定義しました。仕様としてあげられているクラスはすべて\n# Objectクラスのサブクラスなので、Objectクラスのインスタンスメソッドとしてhogeを定義すると仕様を満たせます。\n# Objectクラスではなく、仕様としてあげられていた各クラス(String, Integer, Numeric, Class, Hash, TrueClass)\n# に対してそれぞれ個別にhogeメソッドを定義しても問題ありません。\nclass Object\n  def hoge\n    'hoge'\n  end\nend",
    "testCode": "require 'minitest'\n\nclass TestHoge < Minitest::Test\ndef test_hoge_in_integer\n    assert_equal \"hoge\", 1.hoge\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "02_object_model",
    "id": "02_hierarchy_q1",
    "title": "Hierarchy Q1",
    "description": "Rubyのクラス階層とモジュールの仕組みについての問題。祖先チェーン、メソッド探索、refinementなどを学びます。 (Q1)",
    "problemCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\n# Q1.\n# 次の動作をする C1 class を実装する\n# - C1.ancestors.first(2) が [C1, M1] となる\n# - C1.new.name が 'C1' を返す\nclass C1\n  def name\n    'C1'\n  end\nend",
    "answerCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\n# Q1. 問題の解説\n#\n# M1をC1にincludeすると、継承ツリーはC1の次にM1が位置することになり、仕様を満たせます。\n#\nclass C1\n  include M1\n\n  def name\n    'C1'\n  end\nend",
    "testCode": "require 'minitest'\n\nclass TestHierarchy < Minitest::Test\ndef test_c1_ancestors\n    assert_equal [C1, M1], C1.ancestors.first(2)\n  end\n\ndef test_c1_name\n    assert_equal 'C1', C1.new.name\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "02_object_model",
    "id": "02_hierarchy_q2",
    "title": "Hierarchy Q2",
    "description": "Rubyのクラス階層とモジュールの仕組みについての問題。祖先チェーン、メソッド探索、refinementなどを学びます。 (Q2)",
    "problemCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\n# Q2.\n# 次の動作をする C2 class を実装する\n# - C2.ancestors.first(2) が [M1, C2] となる\n# - C2.new.name が 'M1' を返す\nclass C2\n  def name\n    'C2'\n  end\nend",
    "answerCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\n# Q2. 問題の解説\n#\n# M1をC2にprependすると、継承ツリーはM2の次にC2が位置することになり、仕様を満たせます。\n#\nclass C2\n  prepend M1\n\n  def name\n    'C2'\n  end\nend",
    "testCode": "require 'minitest'\n\nclass TestHierarchy < Minitest::Test\ndef test_c2_ancestors\n    assert_equal [M1, C2], C2.ancestors.first(2)\n  end\n\ndef test_c2_name\n    assert_equal 'M1', C2.new.name\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "02_object_model",
    "id": "02_hierarchy_q3",
    "title": "Hierarchy Q3",
    "description": "Rubyのクラス階層とモジュールの仕組みについての問題。祖先チェーン、メソッド探索、refinementなどを学びます。 (Q3)",
    "problemCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\n# Q3.\n# 次の動作をする C3 class, MySuperClass class を実装する\n# - C3.ancestors.first(6) が [M1, C3, M2, M3, MySuperClass, M4] となる\n# - C3.new.name が 'M1' を返す\nclass C3\n  def name\n    'C3'\n  end\nend",
    "answerCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\n# Q3. 問題の解説\n#\n# モジュールを複数includeしたり、スーパークラスを明示的に定義したときの\n# 継承ツリーがどうなるかの理解を問う問題です\n#\nclass MySuperClass\n  include M4\nend\n\nclass C3 < MySuperClass\n  prepend M1\n  include M3\n  include M2\n\n  def name\n    'C3'\n  end\nend",
    "testCode": "require 'minitest'\n\nclass TestHierarchy < Minitest::Test\ndef test_c3_ancestors\n    assert_equal [M1, C3, M2, M3, MySuperClass, M4], C3.ancestors.first(6)\n  end\n\ndef test_c3_name\n    assert_equal 'M1', C3.new.name\n  end\n\ndef test_c3_super_class\n    assert MySuperClass.kind_of?(Class)\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "02_object_model",
    "id": "02_hierarchy_q4",
    "title": "Hierarchy Q4",
    "description": "Rubyのクラス階層とモジュールの仕組みについての問題。祖先チェーン、メソッド探索、refinementなどを学びます。 (Q4)",
    "problemCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\n# Q4.\n# 次の動作をする C4 class のメソッド increment を実装する\n# - increment メソッドを呼ぶと value が +1 される\n# - また、increment メソッドは value を文字列にしたものを返す\n#   c4 = C4.new\n#   c4.increment # => \"1\"\n#   c4.increment # => \"2\"\n#   c4.increment # => \"3\"\n# - 定義済みのメソッド (value, value=) は private のままとなっている\n# - incrementメソッド内で value, value=を利用する\nclass C4\n  private\n\n  attr_accessor :value\nend",
    "answerCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\n# Q4. 問題の解説\n#\n# privateメソッドとして定義していると、レシーバを明示的に指定したメソッド呼び出しができません。\n# しかしこれには例外があり、レシーバがselfであれば問題ありません。\n# この仕様はRuby2.7からのものであり、2.7未満はセッターメソッド(=が末尾についているもの)のみがselfをつけて呼び出し可能でした。\nclass C4\n  def increment\n    self.value ||= 0\n    self.value += 1\n    value.to_s\n  end\n  private\n\n  attr_accessor :value\nend",
    "testCode": "require 'minitest'\n\nclass TestHierarchy < Minitest::Test\ndef test_c4_increment\n    c4 = C4.new\n    assert_equal \"1\", c4.increment\n    assert_equal \"2\", c4.increment\n    assert_equal \"3\", c4.increment\n  end\n\ndef test_c4_value_called\n    c4 = C4.new\n    c4.singleton_class.class_eval do\n      private\n\n      def value=(x)\n        @called_setter = true\n        @value = x\n      end\n\n      def value\n        @called_getter = true\n        if defined?(@value)\n          @value\n        else\n          nil\n        end\n      end\n    end\n    c4.instance_variable_set(:\"@called_setter\", nil)\n    c4.instance_variable_set(:\"@called_getter\", nil)\n\n    assert_equal \"1\", c4.increment\n    assert c4.instance_variable_get(:\"@called_setter\")\n    assert c4.instance_variable_get(:\"@called_getter\")\n  end\n\ndef test_c4_value_methods\n    assert C4.private_instance_methods.include?(:value)\n    assert C4.private_instance_methods.include?(:value=)\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "02_object_model",
    "id": "02_hierarchy_q5",
    "title": "Hierarchy Q5",
    "description": "Rubyのクラス階層とモジュールの仕組みについての問題。祖先チェーン、メソッド探索、refinementなどを学びます。 (Q5)",
    "problemCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\n# Q5.\n# 次の動作をする M1Refinements module を実装する\n# - M1Refinements は M1 の name インスタンスメソッドをリファインし,\n#   リファインされた name メソッドは \"Refined M1\" を返す\n# - C5.new.another_name が文字列 \"M1\" を返す\n# - C5.new.other_name が文字列 \"Refined M1\" を返す\nmodule M1Refinements\nend\n\nclass C5\n  include M1\n\n  def another_name\n    name\n  end\n\n  using M1Refinements\n\n  def other_name\n    name\n  end\nend",
    "answerCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\n# Q5. 問題の解説\n#\n# refinementsの練習問題です。\n# refineしたメソッドの影響範囲はusingがクラス内であれば、そのusingしたクラス内でのみ、かつusing以降の行です。\nmodule M1Refinements\n  refine M1 do\n    def name\n      'Refined M1'\n    end\n  end\nend\n\nclass C5\n  include M1\n\n  def another_name\n    name\n  end\n\n  using M1Refinements\n\n  def other_name\n    name\n  end\nend",
    "testCode": "require 'minitest'\n\nclass TestHierarchy < Minitest::Test\ndef test_c5_another_name\n    assert_equal \"M1\", C5.new.another_name\n  end\n\ndef test_c5_other_name\n    assert_equal \"Refined M1\", C5.new.other_name\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "02_object_model",
    "id": "02_hierarchy_q6",
    "title": "Hierarchy Q6",
    "description": "Rubyのクラス階層とモジュールの仕組みについての問題。祖先チェーン、メソッド探索、refinementなどを学びます。 (Q6)",
    "problemCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\n# Q6.\n# 次の動作をする C6 class を実装する\n# - M1Refinements は Q5 で実装したものをそのまま使う\n# - C6.new.name が 'Refined M1' を返すように C6 に name メソッドを実装する\nclass C6\n  include M1\n  using M1Refinements\nend",
    "answerCode": "module M1\n  def name\n    'M1'\n  end\nend\n\nmodule M2\n  def name\n    'M2'\n  end\nend\n\nmodule M3\n  def name\n    'M3'\n  end\nend\n\nmodule M4\n  def name\n    'M4'\n  end\nend\n\n# NOTE: これより上の行は変更しないこと\n\n# Q6. 問題の解説\n#\n# Q5の解説でも書いたように、refineしたメソッドの影響範囲はusingがクラス内であれば、そのusingしたクラス内でのみ、かつusing以降の行です。\n# なので、問題として用意したコードのままだとなにもrefineされず、もともとのC6#nameは'M1'を返します。\n# using以降の行でM1#nameを呼び出すC6#nameを定義するとrefineした実装が呼び出されます。\n#\nclass C6\n  include M1\n  using M1Refinements\n\n  def name\n    super\n  end\nend",
    "testCode": "require 'minitest'\n\nmodule M1\n  def name\n    'M1'\n  end\nend\n\nmodule M1Refinements\n  refine M1 do\n    def name\n      'Refined M1'\n    end\n  end\nend\n\nclass TestHierarchy < Minitest::Test\ndef test_c6_name\n    assert_equal \"Refined M1\", C6.new.name\n\n    C6.include(Module.new do\n      def name = \"other\"\n    end)\n    assert_equal \"other\", C6.new.name\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "03_method",
    "id": "01_method_first_step_q1",
    "title": "Method First Step Q1",
    "description": "Rubyのメソッド定義についての基本的な問題。defキーワードを使わない動的なメソッド定義を学びます。 (Q1)",
    "problemCode": "# Q1.\n# 次の動作をする F1 class を実装する\n# - 1. \"def\"キーワードを使わずにF1クラスにhelloインスタンスメソッドを定義すること\n#      戻り値は \"hello\" であること\n# - 2. \"def\"キーワードを使わずにF1クラスにworldクラスメソッドを定義すること\n#      戻り値は \"world\" であること\n# - 3. 定義していないメソッドを実行したときにエラーを発生させず、\"NoMethodError\"という文字列を返すこと\n# - 4. `F1.new.respond_to?(定義していないメソッド名)` を実行したときにtrueを返すこと\n\nclass F1\nend",
    "answerCode": "# Q1. 問題の解説\n#\n# define_methodとdefine_singleton_methodとmethod_missingの素振り用の問題です。\n# define_singleton_methodは3章にはまだ出てきていませんが、これを知らないと3章の問題を解くのが難しくなるので覚えておいてください\n# respond_to_missing?は、respond_to?メソッド実行時にメソッドが定義されていない場合に呼ばれるメソッドです。method_missingを定義する場合は\n# 必ず定義しておきましょう。\n#\nclass F1\n  define_method :hello do\n    'hello'\n  end\n\n  define_singleton_method :world do\n    'world'\n  end\n\n  def method_missing(*args)\n    'NoMethodError'\n  end\n\n  def respond_to_missing?(*args)\n    true\n  end\nend",
    "testCode": "require 'minitest'\n\nclass TestMethodFirstStep < Minitest::Test\ndef test_hello\n    assert_equal F1.new.hello, 'hello'\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "03_method",
    "id": "01_method_first_step_q2",
    "title": "Method First Step Q2",
    "description": "Rubyのメソッド定義についての基本的な問題。defキーワードを使わない動的なメソッド定義を学びます。 (Q2)",
    "problemCode": "# Q2.\n# 次の動作をする F2 classを実装する\n# - 1. 実行するとhiインスタンスメソッドを定義するadd_hiメソッドを定義すること\n\nclass F2\nend",
    "answerCode": "# Q2. 問題の解説\n#\n# メソッドを実行したら新しいメソッドができる、ということを実感してもらうための問題です。この回答のようなdefがネストする実装は普通はやりませんが、\n# 「特定の処理を実行する時に動的にメソッドを生やす」という場面は、メタプロをしていればそれなりにあります。\n#\nclass F2\n  def add_hi\n    def hi\n    end\n  end\nend",
    "testCode": "require 'minitest'\n\nclass TestMethodFirstStep < Minitest::Test\ndef test_world\n    assert_equal F1.world, 'world'\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "03_method",
    "id": "02_define_q1",
    "title": "Define Q1",
    "description": "Rubyのメソッド定義と呼び出しについての問題。動的なメソッド定義やオリジナルアクセサの実装を学びます。 (Q1)",
    "problemCode": "# Q1.\n# 次の動作をする A1 class を実装する\n# - \"//\" を返す \"//\"メソッドが存在すること",
    "answerCode": "# Q1.\n#\n# 問題の解説\n# defだとSyntaxErrorになってしまうようなメソッド名でも、define_methodを使うことでメソッドとして定義することができます。\n#\nclass A1\n  define_method '//' do\n    '//'\n  end\nend\n\n# Q2\n#\n# 問題の解説\n# defind_singleton_methodを利用して動的に特異メソッドを定義することで、条件2を満たしています。\n# define_methodはModuleのインスタンスメソッドなので、initializeメソッド中では使えません。\n# A2.define_methodのようにすれば使えますが、それだとA2クラスのインスタンスメソッドになるので\n# すべてのA2インスタンスで利用できてしまい、\n# 「メソッドが定義されるのは同時に生成されるオブジェクトのみで、別のA2インスタンスには（同じ値を含む配列を生成時に渡さない限り）定義されない」\n# という仕様を満たすことができません。\n#\nclass A2\n  def initialize(ary)\n    ary.each do |name|\n      method_name = \"hoge_#{name}\"\n\n      define_singleton_method method_name do |times|\n        if times.nil?\n          dev_team\n        else\n          method_name * times\n        end\n      end\n    end\n  end\n\n  def dev_team\n    'SmartHR Dev Team'\n  end\nend\n\n# Q3.\n#\n# 問題の解説\n# 3章にはまだ登場していない概念ですが、includedフックを利用してモジュールがincludeされたときの振る舞いを記述しています。\n# my_attr_accessorメソッドはクラスメソッドに相当するため、includedメソッドの引数として渡されてきたクラスに直接define_singleton_methodでメソッドを追加しています。\n# さらにmy_attr_accessorメソッド実行時にインスタンスメソッドを追加するためにdefine_methodを利用しています。\n# セッターで定義した値を格納するために`@my_attr_accessor`をハッシュとして定義して利用しています。\n# `?`つきのメソッドを定義するために、セッター実行時にdefine_aingleton_methodでメソッドを追加しています。\n#\nmodule OriginalAccessor\n  def self.included(base)\n    base.define_singleton_method(:my_attr_accessor) do |attr|\n      base.define_method attr do\n        @my_attr_accessor&.fetch(attr) { nil }\n      end\n\n      base.define_method \"#{attr}=\" do |value|\n        (@my_attr_accessor ||= {})[attr] = value\n\n        if value.is_a?(TrueClass) || value.is_a?(FalseClass)\n          define_singleton_method \"#{attr}?\" do\n            !!value\n          end\n        end\n      end\n    end\n  end\nend",
    "testCode": "require 'minitest'\nrequire 'securerandom'\n\nclass TestDefine < Minitest::Test\ndef test_answer_a1\n    assert_equal \"//\", A1.new.send(\"//\".to_sym)\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "03_method",
    "id": "03_try_over3_3_q1",
    "title": "Try Over3 3 Q1",
    "description": "高度なメタプログラミング技術の問題。method_missing、プロキシオブジェクト、const_missing、DSLの実装などを学びます。 (Q1)",
    "problemCode": "TryOver3 = Module.new\n\n# Q1\n# 以下要件を満たすクラス TryOver3::A1 を作成してください。\n# - run_test というインスタンスメソッドを持ち、それはnilを返す\n# - `test_` から始まるインスタンスメソッドが実行された場合、このクラスは `run_test` メソッドを実行する\n# - `test_` メソッドがこのクラスに実装されていなくても `test_` から始まるメッセージに応答することができる\n# - TryOver3::A1 には `test_` から始まるインスタンスメソッドが定義されていない",
    "answerCode": "TryOver3 = Module.new\n\n# Q1. 問題の解説\n#\n# method_missingを利用してゴーストメソッドを作る問題です。\n# respond_to_missing?はなくてもテストはパスしますが、method_missingを作るときにはセットで\n# 定義しておくのがお作法なので回答例にはrespond_to_missing?も定義しています。\n#\nclass TryOver3::A1\n  def run_test\n  end\n\n  def method_missing(name, *)\n    if name.to_s.start_with?('test_')\n      run_test\n    else\n      super\n    end\n  end\n\n  def respond_to_missing?(name, _)\n    name.to_s.start_with?('test_')\n  end\nend",
    "testCode": "require 'minitest'\nrequire 'minitest/mock'\n\nclass TestTryOver03Q1 < Minitest::Test\ndef test_q1_called_run_test\n    a1 = TryOver3::A1.new\n    mock = Minitest::Mock.new\n    a1.stub(:run_test, mock) do\n      a1.test_hoge\n    end\n    assert mock.verify\n  end\n\ndef test_q1_run_raise_error\n    assert_raises(NoMethodError) { TryOver3::A1.new.testhoge }\n  end\n\ndef test_q1_methods_not_included_test\n    assert_equal false, TryOver3::A1.instance_methods(false).any? { |method_name| method_name.to_s.start_with?(\"test_\") }\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "03_method",
    "id": "03_try_over3_3_q2",
    "title": "Try Over3 3 Q2",
    "description": "高度なメタプログラミング技術の問題。method_missing、プロキシオブジェクト、const_missing、DSLの実装などを学びます。 (Q2)",
    "problemCode": "TryOver3 = Module.new\n\n# Q2\n# 以下要件を満たす TryOver3::A2Proxy クラスを作成してください。\n# - TryOver3::A2Proxy は initialize に TryOver3::A2 のインスタンスを受け取り、それを @source に代入する\n# - TryOver3::A2Proxy は、@sourceに定義されているメソッドが自分自身に定義されているように振る舞う\nclass TryOver3::A2\n  def initialize(name, value)\n    instance_variable_set(\"@#{name}\", value)\n    self.class.attr_accessor name.to_sym unless respond_to? name.to_sym\n  end\nend",
    "answerCode": "TryOver3 = Module.new\n\n# Q2. 問題の解説\n#\n# method_missingとsendを使って動的プロキシを作る問題です。\n# Q1と違い、こちらはrespond_to_missing?がないとテストが失敗します。\n#\nclass TryOver3::A2\n  def initialize(name, value)\n    instance_variable_set(\"@#{name}\", value)\n    self.class.attr_accessor name.to_sym unless respond_to? name.to_sym\n  end\nend\n\nclass TryOver3::A2Proxy\n  def initialize(source)\n    @source = source\n  end\n\n  def method_missing(...)\n    @source.send(...)\n  end\n\n  def respond_to_missing?(name, include_all)\n    @source.respond_to?(name, include_all)\n  end\nend\n\n# Q3.\n# Module#remove_methodを利用するとメソッドを削除できます。これを使い、\n# 「boolean 以外が入っている場合には #{name}? メソッドが存在しないようにする」を実現します。\n# なお、メソッドを削除するメソッドはremove_methodの他にundef_methodも存在します。こちらでもテストはパスします。\n# remove_methodとundef_methodの違いが気になる方はドキュメントを読んでみてください。\n#\nmodule TryOver3::OriginalAccessor2\n  def self.included(mod)\n    mod.define_singleton_method :my_attr_accessor do |name|\n      define_method name do\n        @attr\n      end\n\n      define_method \"#{name}=\" do |value|\n        if [true, false].include?(value) && !respond_to?(\"#{name}?\")\n          self.class.define_method \"#{name}?\" do\n            @attr == true\n          end\n        else\n          mod.remove_method \"#{name}?\" if respond_to? \"#{name}?\"\n        end\n        @attr = value\n      end\n    end\n  end\nend",
    "testCode": "require 'minitest'\nrequire 'minitest/mock'\n\nclass TestTryOver03Q1 < Minitest::Test\ndef test_q2_proxy_foo\n    source = TryOver3::A2.new(\"foo\", \"foofoo\")\n    assert_equal \"foofoo\", TryOver3::A2Proxy.new(source).foo\n  end\n\ndef test_q2_proxy_hoge_writer\n    source = TryOver3::A2.new(\"foo\", \"foo\")\n    proxy = TryOver3::A2Proxy.new(source)\n    proxy.foo = \"foofoo\"\n    assert_equal \"foofoo\", proxy.foo\n  end\n\ndef test_q2_proxy_rand\n    name = alpha_rand\n    source = TryOver3::A2.new(name, \"foo\")\n    assert_equal \"foo\", TryOver3::A2Proxy.new(source).public_send(name)\n  end\n\ndef test_q2_proxy_respond_to_foo\n    source = TryOver3::A2.new(\"foo\", \"foofoo\")\n    assert_respond_to TryOver3::A2Proxy.new(source), :foo\n  end\n\ndef test_q2_proxy_methods_not_included_foo\n    source = TryOver3::A2.new(\"foo\", \"foofoo\")\n    refute_includes TryOver3::A2Proxy.new(source).methods, :foo\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "03_method",
    "id": "03_try_over3_3_q4",
    "title": "Try Over3 3 Q4",
    "description": "高度なメタプログラミング技術の問題。method_missing、プロキシオブジェクト、const_missing、DSLの実装などを学びます。 (Q4)",
    "problemCode": "TryOver3 = Module.new\n\n# Q4\n# 以下のように実行できる TryOver3::A4 クラスを作成してください。\n# TryOver3::A4.runners = [:Hoge]\n# TryOver3::A4::Hoge.run\n# # => \"run Hoge\"\n# このとき、TryOver3::A4::Hogeという定数は定義されません。\n\n\n# Q5. チャレンジ問題！ 挑戦する方はテストの skip を外して挑戦してみてください。\n#\n# TryOver3::TaskHelper という include すると task というクラスマクロが与えられる以下のようなモジュールがあります。\nmodule TryOver3::TaskHelper\n  def self.included(klass)\n    klass.define_singleton_method :task do |name, &task_block|\n      new_klass = Class.new do\n        define_singleton_method :run do\n          puts \"start #{Time.now}\"\n          block_return = task_block.call\n          puts \"finish #{Time.now}\"\n          block_return\n        end\n      end\n      new_klass_name = name.to_s.split(\"_\").map{ |w| w[0] = w[0].upcase; w }.join\n      const_set(new_klass_name, new_klass)\n    end\n  end\nend\n\n# TryOver3::TaskHelper は include することで以下のような使い方ができます\nclass TryOver3::A5Task\n  include TryOver3::TaskHelper\n\n  task :foo do\n    \"foo\"\n  end\nend\n# irb(main):001:0> TryOver3::A3Task::Foo.run\n# start 2020-01-07 18:03:10 +0900\n# finish 2020-01-07 18:03:10 +0900\n# => \"foo\"\n\n# 今回 TryOver3::TaskHelper では TryOver3::A5Task::Foo のように Foo クラスを作らず\n# TryOver3::A5Task.foo のようにクラスメソッドとして task で定義された名前のクラスメソッドでブロックを実行するように変更したいです。\n# 現在 TryOver3::TaskHelper のユーザには TryOver3::A5Task::Foo.run のように生成されたクラスを使って実行しているユーザが存在します。\n# 今回変更を加えても、その人たちにはこれまで通り生成されたクラスのrunメソッドでタスクを実行できるようにしておいて、\n# warning だけだしておくようにしたいです。\n# TryOver3::TaskHelper を修正してそれを実現してください。 なお、その際、クラスは実行されない限り生成されないものとします。\n#\n# 変更後想定する使い方\n# メソッドを使ったケース\n# irb(main):001:0> TryOver3::A5Task.foo\n# start 2020-01-07 18:03:10 +0900\n# finish 2020-01-07 18:03:10 +0900\n# => \"foo\"\n#\n# クラスのrunメソッドを使ったケース\n# irb(main):001:0> TryOver3::A5Task::Foo.run\n# Warning: TryOver3::A5Task::Foo.run is deprecated\n# start 2020-01-07 18:03:10 +0900\n# finish 2020-01-07 18:03:10 +0900\n# => \"foo\"",
    "answerCode": "TryOver3 = Module.new\n\n# Q4. 問題の解説\n#\n# const_missingを利用して、runners=で定義した定数を参照したときにrunメソッドを持つオブジェクトを返すことで\n# 仕様を満たしています。回答例ではObject.newでオブジェクトを生成しましたが、runメソッドを持つオブジェクトであれば\n# どんなクラスのインスタンスでもOKです。\n#\nclass TryOver3::A4\n  def self.const_missing(const)\n    if @consts.include?(const)\n      obj = Object.new\n      obj.define_singleton_method(:run) { \"run #{const}\" }\n      obj\n    else\n      super\n    end\n  end\n\n  def self.runners=(consts)\n    @consts = consts\n  end\nend",
    "testCode": "require 'minitest'\nrequire 'minitest/mock'\n\nclass TestTryOver03Q1 < Minitest::Test\ndef test_q4_call_class\n    TryOver3::A4.runners = [:Hoge]\n    assert_equal \"run Hoge\", TryOver3::A4::Hoge.run\n  end\n\ndef test_q4_raise_error_when_called_not_runner_class\n    TryOver3::A4.runners = [:Hoge]\n    assert_raises(NameError) { TryOver3::A4::Foo }\n  end\n\ndef test_q4_not_exists_runner_class\n    TryOver3::A4.runners = [:Hoge]\n    refute_includes(TryOver3::A4.constants, :Hoge)\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "04_block",
    "id": "01_block_first_step_q1",
    "title": "Block First Step Q1",
    "description": "Rubyのブロックについての基本的な問題。ブロックの受け渡しや実行、クロージャについて学びます。 (Q1)",
    "problemCode": "# Q1.\n# MyMathクラスに、ブロックを実行した結果(数値)を2倍にして返すtwo_timesインスタンスメソッドを定義しましょう\n#    実行例: MyMath.new.two_times { 2 } #=> 4\n\nclass MyMath\nend",
    "answerCode": "# Q1. 問題の解説\n#\n# yieldもしくはcallメソッドを使うメソッド実装の練習です。Railsでアプリケーションを書いているとそれほどブロックを取る\n# メソッドを書く機会はないのですが、素振りをしておいていざというときに使えるようにしておくと役に立つ時が来るかもしれません\nclass MyMath\n  def two_times\n    yield * 2\n  end\nend",
    "testCode": "require 'minitest'\n\nclass AcceptBlock\n  class << self\n    attr_accessor :result\n  end\n\n  def self.call(&block)\n    @result = block == MY_LAMBDA\n  end\nend\n\nclass TestBlockFirstStep < Minitest::Test\ndef test_my_math\n    assert_equal 4, MyMath.new.two_times { 2 }\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "04_block",
    "id": "01_block_first_step_q2",
    "title": "Block First Step Q2",
    "description": "Rubyのブロックについての基本的な問題。ブロックの受け渡しや実行、クロージャについて学びます。 (Q2)",
    "problemCode": "# Q2.\n# AcceptBlockクラスにcallクラスメソッドが予め定義されており、このメソッドがブロックをとるとします。\n# 実行例: AcceptBlock.call { 2 }\n# このメソッドを、下で用意されているMY_LAMBDAをブロック引数として渡して実行してみてください。\n# AcceptBlockクラスは問題側で用意している(テスト中に実装している)ため実装の必要はありません。\n\nMY_LAMBDA = -> { 3 }",
    "answerCode": "# Q2. 問題の解説\n#\n# Procオブジェクトをブロック引数として渡す練習です。実引数を渡すところで`&`を使うと、Procからブロックへの変換ができます。\nMY_LAMBDA = -> { 3 }\nAcceptBlock.call(&MY_LAMBDA)",
    "testCode": "require 'minitest'\n\nclass AcceptBlock\n  class << self\n    attr_accessor :result\n  end\n\n  def self.call(&block)\n    @result = block == MY_LAMBDA\n  end\nend\n\nclass TestBlockFirstStep < Minitest::Test\ndef test_accept_block\n    assert AcceptBlock.result\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "04_block",
    "id": "01_block_first_step_q3",
    "title": "Block First Step Q3",
    "description": "Rubyのブロックについての基本的な問題。ブロックの受け渡しや実行、クロージャについて学びます。 (Q3)",
    "problemCode": "# Q3.\n# MyBlockクラスにblock_to_procインスタンスメソッドを定義しましょう。block_to_procインスタンスメソッドはブロックを受け取り、\n# そのブロックをProcオブジェクトにしたものを返します\n\nclass MyBlock\nend",
    "answerCode": "# Q3. 問題の解説\n#\n# Q2と反対に、ブロックからProcオブジェクトの変換をする練習です。仮引数で&を使うとブロックからProcオブジェクトへの変換ができます。\nclass MyBlock\n  def block_to_proc(&block)\n    block\n  end\nend",
    "testCode": "require 'minitest'\n\nclass AcceptBlock\n  class << self\n    attr_accessor :result\n  end\n\n  def self.call(&block)\n    @result = block == MY_LAMBDA\n  end\nend\n\nclass TestBlockFirstStep < Minitest::Test\ndef test_my_block\n    assert_equal(MY_LAMBDA, MyBlock.new.block_to_proc(&MY_LAMBDA))\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "04_block",
    "id": "01_block_first_step_q4",
    "title": "Block First Step Q4",
    "description": "Rubyのブロックについての基本的な問題。ブロックの受け渡しや実行、クロージャについて学びます。 (Q4)",
    "problemCode": "# Q4.\n# MyClosureクラスにincrementインスタンスメソッドを定義しましょう。このincrementメソッドは次のように数値を1ずつインクリメントして返します\n# my = MyClosure.new\n# my.increment #=> 1\n# my.increment #=> 2\n# my.increment #=> 3\n# それに加えて、複数のインスタンスでカウンターを共有しているという特性があります。\n# my1 = MyClosure.new\n# my2 = MyClosure.new\n# my1.increment #=> 1\n# my2.increment #=> 2\n# my1.increment #=> 3\n# さらなる制限として、カウンターとして利用する変数はローカル変数を利用してください(これはテストにはないですが頑張ってローカル変数でテストを通るようにしてみてください)\n\nclass MyClosure\nend",
    "answerCode": "# Q4. 問題の解説\n#\n# クロージャを実装してみる練習です。ブロックを利用するとスコープゲートなしで束縛を利用できるのでしたね。メソッド定義をdefではなく\n# define_method にすることで外側のローカル変数への参照を持ち続けることができます。\nclass MyClosure\n  count = 0\n\n  define_method :increment do\n    count += 1\n  end\nend",
    "testCode": "require 'minitest'\n\nclass AcceptBlock\n  class << self\n    attr_accessor :result\n  end\n\n  def self.call(&block)\n    @result = block == MY_LAMBDA\n  end\nend\n\nclass TestBlockFirstStep < Minitest::Test\ndef test_my_closure\n    m1 = MyClosure.new\n    m2 = MyClosure.new\n    assert_equal(1, m1.increment)\n    assert_equal(2, m2.increment)\n    assert_equal(3, m1.increment)\n    MyClosure\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "04_block",
    "id": "02_evil_mailbox",
    "title": "Evil Mailbox",
    "description": "複雑なブロック処理とクロージャキャプチャを使ったメールボックスの実装問題。認証機能や秘密文字列の処理を学びます。",
    "problemCode": "# 次の仕様を満たすクラス、EvilMailboxを作成してください\n#\n# 基本機能\n# 1. EvilMailboxは、コンストラクタで一つのオブジェクトを受け取る（このオブジェクトは、メールの送受信機能が実装されているが、それが何なのかは気にする必要はない）\n# 2. EvilMailboxは、メールを送るメソッド `send_mail` を持ち、引数として宛先の文字列、本文の文字列を受け取る。結果の如何に関わらず、メソッドはnilをかえす。\n# 3. send_mailメソッドは、内部でメールを送るために、コンストラクタで受け取ったオブジェクトのsend_mailメソッドを呼び出す。このときのシグネチャは同じである。また、このメソッドはメールの送信が成功したか失敗したかをbool値で返す。\n# 4. EvilMailboxは、メールを受信するメソッド `receive_mail` を持つ\n# 5. receive_mailメソッドは、メールを受信するためにコンストラクタで受け取ったオブジェクトのreceive_mailメソッドを呼び出す。このオブジェクトのreceive_mailは、送信者と本文の2つの要素をもつ配列を返す。\n# 6. receive_mailメソッドは、受け取ったメールを送信者と本文の2つの要素をもつ配列として返す\n#\n# 応用機能\n# 1. send_mailメソッドは、ブロックを受けとることができる。ブロックは、送信の成功/失敗の結果をBool値で引数に受け取ることができる\n# 2. コンストラクタは、第2引数として文字列を受け取ることができる（デフォルトはnilである）\n# 3. コンストラクタが第2引数として文字列を受け取った時、第1引数のオブジェクトはその文字列を引数にしてauthメソッドを呼び出す\n# 4. 第2引数の文字列は、秘密の文字列のため、EvilMailboxのオブジェクトの中でいかなる形でも保存してはいけない\n#\n# 邪悪な機能\n# 1. send_mailメソッドは、もしも\"コンストラクタで受け取ったオブジェクトがauthメソッドを呼んだ\"とき、勝手にその認証に使った文字列を、送信するtextの末尾に付け加える\n# 2. つまり、コンストラクタが第2引数に文字列を受け取った時、その文字列はオブジェクト内に保存されないが、send_mailを呼び出したときにこっそりと勝手に送信される",
    "answerCode": "# 問題の解説\n#\n# 仕様の「邪悪な機能」をクロージャを使って実装することに気付けるかどうかを問う問題です。\n# initializeメソッドの中でdefine_singleton_methodを利用してsend_mailメソッドを定義することで、\n# initializeメソッドのローカル変数として第2引数を扱います。こうすることで、\n# send_mailメソッドの中でしか参照できない変数ができあがります。\n\nclass EvilMailbox\n  def initialize(obj, str = nil)\n    @obj = obj\n    @obj.auth(str) if str\n\n    define_singleton_method(:send_mail) do |to, body, &block|\n      result = obj.send_mail(to, body + str.to_s)\n      block.call(result) if block\n      nil\n    end\n  end\n\n  def receive_mail\n    obj.receive_mail\n  end\n\n  private\n\n  attr_reader :obj\nend",
    "testCode": "require 'minitest'\n\nclass TestEvilMailbox < Minitest::Test\n  def evil_mailbox(&block)\n    mock = Minitest::Mock.new\n    mock.instance_eval(&block) if block_given?\n    [EvilMailbox.new(mock), mock]\n  end\n\n  def test_send_mail\n    mb, mock = evil_mailbox do\n      expect :send_mail, true, [\"ppyd\", \"hello\"]\n    end\n    mb.send_mail(\"ppyd\", \"hello\")\n    mock.verify\n  end\n\n  def test_send_mail_returns_nil\n    mb, _ = evil_mailbox do\n      expect :send_mail, true, [\"ppyd\", \"hello\"]\n    end\n    assert_nil mb.send_mail(\"ppyd\", \"hello\")\n  end\n\n  def test_receive_mail\n    mb, mock = evil_mailbox do\n      expect :receive_mail, [\"kino\", \"Yo\"]\n    end\n    f, t = mb.receive_mail\n    mock.verify\n    assert_equal \"kino\", f\n    assert_equal \"Yo\", t\n  end\n\n  def test_send_mail_exec_block_with_result_true\n    mb, _ = evil_mailbox do\n      expect :send_mail, true, [\"ppyd\", \"hello\"]\n    end\n    ret = nil\n    mb.send_mail(\"ppyd\", \"hello\") do |res|\n      ret = res\n    end\n    assert_equal true, ret\n  end\n\n  def test_send_mail_exec_block_with_result_false\n    mb, _ = evil_mailbox do\n      expect :send_mail, false, [\"ppyd\", \"hello\"]\n    end\n    ret = nil\n    mb.send_mail(\"ppyd\", \"hello\") do |res|\n      ret = res\n    end\n    assert_equal false, ret\n  end\n\n  def test_mail_object_auth\n    secret_string = SecureRandom.hex\n    mock = Minitest::Mock.new\n    mock.expect :auth, true, [String]\n    EvilMailbox.new(mock, secret_string)\n    mock.verify\n  end\n\n  def test_send_mail_with_secret_string\n    secret_string = SecureRandom.hex\n    mock = Minitest::Mock.new\n    mock.expect :auth, true, [String]\n    mock.expect :send_mail, true, [\"ppyd\", \"hello#{secret_string}\"]\n    mb = EvilMailbox.new(mock, secret_string)\n\n    mb.send_mail(\"ppyd\", \"hello\")\n    mock.verify\n  end\n\n  def test_no_secret_string_in_object\n    secret_string = SecureRandom.hex\n    mock = Minitest::Mock.new\n    mock.expect :auth, true, [String]\n    mb = EvilMailbox.new(mock, secret_string)\n\n    mock.verify\n    mb.class.send(:class_variables).each do |cv|\n      assert_equal false, secret_string == mb.class.get_class_variable(cv)\n    end\n    mb.send(:instance_variables).each do |iv|\n      assert_equal false, secret_string == mb.instance_variable_get(iv)\n    end\n  end\n\n  def evil_mailbox_with_secret_string(secret_string, &block)\n    mock = Minitest::Mock.new\n    mock.instance_eval(&block) if block_given?\n    [EvilMailbox.new(mock, secret_string), mock]\n  end\n\n  def test_send_mail_exec_block_with_result_true_and_secret_string\n    secret_string = SecureRandom.hex\n    mb, mock = evil_mailbox_with_secret_string(secret_string) do\n      expect :auth, true, [String]\n      expect :send_mail, true, [\"ppyd\", \"hello#{secret_string}\"]\n    end\n\n    ret = nil\n    mb.send_mail(\"ppyd\", \"hello\") do |res|\n      ret = res\n    end\n    mock.verify\n    assert_equal true, ret\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "04_block",
    "id": "03_simple_bot",
    "title": "Simple Bot",
    "description": "ブロックを使ったDSLの作成問題。ボット作成のためのDSLを実装して、respond、setting、settingsメソッドを学びます。",
    "problemCode": "# 次の仕様を満たすSimpleBotクラスとDSLを作成してください\n#\n# # これは、作成するSimpleBotクラスの利用イメージです\n# class Bot < SimpleBot\n#   setting :name, 'bot'\n#   respond 'keyword' do\n#     \"response #{settings.name}\"\n#   end\n# end\n#\n# Bot.new.ask('keyword') #=> 'respond bot'\n#\n# 1. SimpleBotクラスを継承したクラスは、クラスメソッドrespond, setting, settingsを持ちます\n#     1. settingsメソッドは、任意のオブジェクトを返します\n#     2. settingsメソッドは、後述するクラスメソッドsettingによって渡された第一引数と同名のメソッド呼び出しに応答します\n# 2. SimpleBotクラスのサブクラスのインスタンスは、インスタンスメソッドaskを持ちます\n#     1. askは、一つの引数をとります\n#     2. askに渡されたオブジェクトが、後述するrespondメソッドで設定したオブジェクトと一致する場合、インスタンスは任意の返り値を持ちます\n#     3. 2のケースに当てはまらない場合、askメソッドの戻り値はnilです\n# 3. クラスメソッドrespondは、keywordとブロックを引数に取ります\n#     1. respondメソッドの第1引数keywordと同じ文字列が、インスタンスメソッドaskに渡された時、第2引数に渡したブロックが実行され、その結果が返されます\n# 4. クラスメソッドsettingは、引数を2つ取り、1つ目がキー名、2つ目が設定する値です\n#     1. settingメソッドに渡された値は、クラスメソッド `settings` から返されるオブジェクトに、メソッド名としてアクセスすることで取り出すことができます\n#     2. e.g. クラス内で `setting :name, 'bot'` と実行した場合は、respondメソッドに渡されるブロックのスコープ内で `settings.name` の戻り値は `bot` の文字列になります",
    "answerCode": "# 問題の解説\n#\n# respondクラスメソッドで定義したブロックを、askインスタンスメソッドからどうやって参照するか、というのが\n# この問題の難所です。クラスメソッドで定義したインスタンス変数はクラスインスタンス変数としてクラスそのものに\n# 紐づくインスタンス変数になるので、インスタンスメソッドから参照するには、回答例のように\n# `self.class.instance_variable_get(インスタンス変数名)`のようにします。\n# クラス変数を利用するとクラスメソッド、インスタンスメソッドどちらからでも`@@respond`のようにアクセスできるので\n# 一見便利ですが、意図せず別のクラスとクラス変数が共有される可能性があるため、推奨しません。\n#\n# SimpleBotとそのサブクラスで利用イメージのように定義されたブロックは、settingsクラスメソッドにアクセスできます。\n# settingsクラスメソッドは、settingクラスメソッドで登録したキーと値をそれぞれメソッド名とその返り値に持つオブジェクトを返すと\n# 仕様を満たせます。メソッドが定義できればどんなオブジェクトを返しても仕様を満たせるため、この回答例では\n# 特異メソッドを定義したObjectインスタンスを返しています。必ずしもObjectインスタンスである必要はありません。\n#\nclass SimpleBot\n  class << self\n    def respond(keyword, &block)\n      @respond ||= {}\n      @respond[keyword] = block\n    end\n\n    def setting(key, value)\n      @settings ||= {}\n      @settings[key] = value\n    end\n\n    def settings\n      obj = Object.new\n\n      @settings&.each do |key, value|\n        obj.define_singleton_method(key) do\n          value\n        end\n      end\n      obj\n    end\n  end\n\n  def ask(keyword)\n    block = self.class.instance_variable_get(:@respond)[keyword]\n    block.call if block\n  end\nend",
    "testCode": "require 'minitest'\n\nclass TestSimpleBot < Minitest::Test\n  def bot_for_test(&block)\n    Class.new(SimpleBot, &block)\n  end\n\n  def test_response\n    klass = bot_for_test do\n      respond 'hello' do\n        'Yo'\n      end\n    end\n\n    assert_equal 'Yo', klass.new.ask('hello')\n  end\n\n  def test_no_response\n    klass = bot_for_test do\n      respond 'yo' do\n        'yo'\n      end\n    end\n\n    assert_nil klass.new.ask(\"hello\")\n  end\n\n  def test_global_setting\n    klass = bot_for_test do\n      setting :name, 'bot'\n      respond 'what is your name?' do\n        \"i'm #{settings.name}\"\n      end\n    end\n\n    assert_equal \"i'm bot\", klass.new.ask(\"what is your name?\")\n  end\n\n  def test_global_setting_random\n    code = SecureRandom.hex\n\n    klass = bot_for_test do\n      setting :code, code\n      respond 'tell me your code' do\n        \"code is #{settings.code}\"\n      end\n    end\n\n    assert_equal \"code is #{code}\", klass.new.ask('tell me your code')\n  end\n\n  def test_global_setting_multiple_call\n    klass = bot_for_test do\n      setting :name, 'bot'\n      setting :age, 10\n      respond 'what is your name?' do\n        \"i'm #{settings.name}\"\n      end\n      respond 'how old are you?' do\n        \"i'm #{settings.age} years old\"\n      end\n    end\n\n    assert_equal \"i'm bot\", klass.new.ask(\"what is your name?\")\n    assert_equal \"i'm 10 years old\", klass.new.ask(\"how old are you?\")\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "05_class_definition",
    "id": "01_class_definition_first_step_q1",
    "title": "Class Definition First Step Q1",
    "description": "Rubyのクラス定義についての基本的な問題。無名クラス、メタプログラミング、スコープゲートなどを学びます。 (Q1)",
    "problemCode": "# 1. ExClassクラスのオブジェクトが2つあります。これらをJudgement.callに渡しています。\n#    Judement.callはテスト側で定義するので実装は不要です。この状況でe2オブジェクト\"だけ\"helloメソッドを\n#    使えるようにしてください。helloメソッドの中身は何でも良いです。\n\nclass ExClass\nend\n\ne1 = ExClass.new\ne2 = ExClass.new\n\nJudgement.call(e1, e2)\n\n# 2. ExClassを継承したクラスを作成してください。ただし、そのクラスは定数がない無名のクラスだとします。\n#    その無名クラスをそのままJudgement2.call の引数として渡してください(Judgement2.callはテスト側で定義するので実装は不要です)\n\n\n# 3. 下のMetaClassに対し、次のように`meta_`というプレフィックスが属性名に自動でつき、ゲッターの戻り値の文字列にも'meta 'が自動でつく\n#    attr_accessorのようなメソッドであるmeta_attr_accessorを作ってください。セッターに文字列以外の引数がくることは考えないとします。\n#\n#    使用例:\n#\n#    class MetaClass\n#      # meta_attr_accessor自体の定義は省略\n#      meta_attr_accessor :hello\n#    end\n#    meta = MetaClass.new\n#    meta.meta_hello = 'world'\n#    meta.meta_hello #=> 'meta world'\n\nclass MetaClass\nend\n\n# 4. 次のようなExConfigクラスを作成してください。ただし、グローバル変数、クラス変数は使わないものとします。\n#    使用例:\n#    ExConfig.config = 'hello'\n#    ExConfig.config #=> 'hello'\n#    ex = ExConfig.new\n#    ex.config #=> 'hello'\n#    ex.config = 'world'\n#    ExConfig.config #=> 'world'\n\n\nclass ExConfig\nend\n\n# 5.\n# ExOver#helloというメソッドがライブラリとして定義されているとします。ExOver#helloメソッドを実行したとき、\n# helloメソッドの前にExOver#before、helloメソッドの後にExOver#afterを実行させるようにExOverを変更しましょう。\n# ただしExOver#hello, ExOver#before, ExOver#afterの実装はそれぞれテスト側で定義しているので実装不要(変更不可)です。\n#\n\n\nclass ExOver\nend\n\n# 6. 次の toplevellocal ローカル変数の中身を返す MyGreeting#say を実装してみてください。\n#    ただし、下のMyGreetingは編集しないものとします。toplevellocal ローカル変数の定義の下の行から編集してください。\n#    ヒント: スコープゲートを乗り越える方法について書籍にありましたね\n\nclass MyGreeting\nend\n\ntoplevellocal = 'hi'",
    "answerCode": "# Q1. 問題の解説\n# e2オブジェクトの特異メソッドとしてhelloを定義する練習です。特異メソッドは対象のオブジェクトだけが利用可能なメソッドです。\n#\nclass ExClass\nend\n\ne1 = ExClass.new\ne2 = ExClass.new\n\ndef e2.hello\nend\n\nJudgement.call(e1, e2)",
    "testCode": "require 'minitest'\n\nclass Judgement\n  def self.call(e1, e2)\n    @e1 = e1\n    @e2 = e2\n  end\nend\n\nclass Judgement2\n  def self.call(klass)\n    @klass = klass\n  end\nend\n\nclass ExOver\n  attr_accessor :result\n\n  def initialize\n    self.result = ''\n  end\n\n  def before\n    result << 'before'\n  end\n\n  def hello\n    result << 'hello'\n  end\n\n  def after\n    result << 'after'\n  end\nend\n\nclass TestClassDefinitionFirstStep < Minitest::Test\ndef test_judgement\n    e1 = Judgement.instance_variable_get(:@e1)\n    e2 = Judgement.instance_variable_get(:@e2)\n    assert e1.is_a?(ExClass)\n    assert e2.is_a?(ExClass)\n    refute e1.respond_to?(:hello)\n    assert e2.respond_to?(:hello)\n  end\nend\n\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "05_class_definition",
    "id": "02_simple_mock",
    "title": "Simple Mock",
    "description": "シンプルなモックフレームワークの作成問題。モックオブジェクトの作成、メソッド呼び出し回数の追跡などを学びます。",
    "problemCode": "# 次の仕様を満たすモジュール SimpleMock を作成してください\n#\n# SimpleMockは、次の2つの方法でモックオブジェクトを作成できます\n# 特に、2の方法では、他のオブジェクトにモック機能を付与します\n# この時、もとのオブジェクトの能力が失われてはいけません\n# また、これの方法で作成したオブジェクトを、以後モック化されたオブジェクトと呼びます\n# 1.\n# ```\n# SimpleMock.new\n# ```\n#\n# 2.\n# ```\n# obj = SomeClass.new\n# SimpleMock.mock(obj)\n# ```\n#\n# モック化したオブジェクトは、expectsメソッドに応答します\n# expectsメソッドには2つの引数があり、それぞれ応答を期待するメソッド名と、そのメソッドを呼び出したときの戻り値です\n# ```\n# obj = SimpleMock.new\n# obj.expects(:imitated_method, true)\n# obj.imitated_method #=> true\n# ```\n# モック化したオブジェクトは、expectsの第一引数に渡した名前のメソッド呼び出しに反応するようになります\n# そして、第2引数に渡したオブジェクトを返します\n#\n# モック化したオブジェクトは、watchメソッドとcalled_timesメソッドに応答します\n# これらのメソッドは、それぞれ1つの引数を受け取ります\n# watchメソッドに渡した名前のメソッドが呼び出されるたび、モック化したオブジェクトは内部でその回数を数えます\n# そしてその回数は、called_timesメソッドに同じ名前の引数が渡された時、その時点での回数を参照することができます\n# ```\n# obj = SimpleMock.new\n# obj.expects(:imitated_method, true)\n# obj.watch(:imitated_method)\n# obj.imitated_method #=> true\n# obj.imitated_method #=> true\n# obj.called_times(:imitated_method) #=> 2\n# ```",
    "answerCode": "# 問題の解説\n# まずmockメソッドの実装から考えます。「もとのオブジェクトの能力が失われてはいけない」という仕様から、引数として受け付けたオブジェクトに\n# SimpleMockをextendすることでモック化に必要なメソッドであるexpects, watch, called_timesを追加するようにします。\n#\n# expectsメソッドを実行したとき、レシーバとなるオブジェクトにだけメソッドを追加したいのでdefine_singleton_methodを利用して動的にメソッドを追加します。\n# メソッドの内容は、次のようにexpectsメソッドに続けてwatchメソッドが実行されたときに備えて、\n# カウンター用のインスタンス変数`@counter`(キーがexpectsで指定されたメソッド名、値が実行回数のハッシュ)を用意して\n# watchが実行されていたら(つまり対応する`@counter`の値があれば)それをインクリメントするようにします。\n#\n# ```ruby\n# obj = Object.new\n# obj = SimpleMock(obj)\n# obj.expects(:hoge, true)\n# obj.watch(:hoge)\n# obj.hoge #=> true\n# ````\n#\n# また、watchを実行したときにexpects経由で定義したメソッドを上書きしないように、expectsしたメソッド名を`@expects`に配列として保存しておきます。\n# watchでは`@expects`を見て、すでにexpectsで定義済みであればメソッドを上書きしないようにします。\n# そうしないとwatchメソッドを実行したときに、モックメソッドの戻り値の情報が失われてしまいます。\n#\n# 次にnewメソッドの実装を考えます。仕様から、SimpleMockはモジュールであることを求められていますが、\n# 同時にモジュールには存在しないnewメソッドを持つようにも求められています。\n# これを、クラスメソッドのnewを明示的に定義することで満たします。このとき何らかのオブジェクトをmockメソッドの引数にして、\n# 戻り値を返すようにすれば要件は満たせますが、モック用のオブジェクトとしては余計なメソッドをなるべく持たない方が扱いやすいので、\n# Object.newをmockメソッドの引数にしています。\n#\nmodule SimpleMock\n  def self.mock(obj)\n    obj.extend(SimpleMock)\n    obj\n  end\n\n  def self.new\n    obj = Object.new\n    mock(obj)\n  end\n\n  def expects(name, value)\n    define_singleton_method(name) do\n      @counter[name] += 1 if @counter&.key?(name)\n      value\n    end\n    @expects ||= []\n    @expects.push(name.to_sym)\n  end\n\n  def watch(name)\n    (@counter ||= {})[name] = 0\n\n    return if @expects&.include?(name.to_sym)\n\n    define_singleton_method(name) do\n      @counter[name] += 1\n    end\n  end\n\n  def called_times(name)\n    @counter[name]\n  end\nend",
    "testCode": "require 'minitest'\n\nclass TestSimpleMock < Minitest::Test\n  class ClassForMockTest\n    def hoge; \"hoge\"; end\n  end\n\n  def test_mock_initialize\n    obj = SimpleMock.new\n    assert_kind_of SimpleMock, obj\n  end\n\n  def test_mock_extend\n    obj = ClassForMockTest.new\n    SimpleMock.mock(obj)\n\n    assert_kind_of SimpleMock, obj\n  end\n\n  def test_mock_retuns_setted_value_when_instance\n    obj = SimpleMock.new\n    expected = SecureRandom.hex\n    obj.expects(:imitated_method, expected)\n\n    assert_equal obj.imitated_method, expected\n  end\n\n  def test_mock_returns_setted_value_when_extended\n    obj = ClassForMockTest.new\n    SimpleMock.mock(obj)\n    expected = SecureRandom.hex\n    obj.expects(:imitated_method, expected)\n\n    assert_equal obj.imitated_method, expected\n  end\n\n  def test_mock_counts_how_many_times_called_method\n    obj = SimpleMock.mock(ClassForMockTest.new)\n    obj.watch(:hoge)\n\n    obj.hoge\n    obj.hoge\n    obj.hoge\n\n    assert_equal 3, obj.called_times(:hoge)\n  end\n\n  def test_mock_counts_how_many_times_called_mocked_method\n    obj = SimpleMock.new\n    obj.expects(:imitated_method, true)\n    obj.watch(:imitated_method)\n\n    obj.imitated_method\n    obj.imitated_method\n\n    assert_equal 2, obj.called_times(:imitated_method)\n  end\n\n  def test_mock_returns_value_and_counts_how_many_times\n    obj = SimpleMock.new\n    obj.expects(:imitated_method, 'hoge')\n    obj.watch(:imitated_method)\n\n    assert_equal('hoge', obj.imitated_method)\n    assert_equal('hoge', obj.imitated_method)\n\n    assert_equal 2, obj.called_times(:imitated_method)\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  },
  {
    "section": "06_codes_generate_codes",
    "id": "01_simple_model",
    "title": "Simple Model",
    "description": "ActiveRecordライクなモデルの実装問題。変更追跡機能付きのattr_accessorとrestoreメソッドを学びます。",
    "problemCode": "# 次の仕様を満たす、SimpleModelモジュールを作成してください\n#\n# 1. include されたクラスがattr_accessorを使用すると、以下の追加動作を行う\n#   1. 作成したアクセサのreaderメソッドは、通常通りの動作を行う\n#   2. 作成したアクセサのwriterメソッドは、通常に加え以下の動作を行う\n#     1. 何らかの方法で、writerメソッドを利用した値の書き込み履歴を記憶する\n#     2. いずれかのwriterメソッド経由で更新をした履歴がある場合、 `true` を返すメソッド `changed?` を作成する\n#     3. 個別のwriterメソッド経由で更新した履歴を取得できるメソッド、 `ATTR_changed?` を作成する\n#       1. 例として、`attr_accessor :name, :desc`　とした時、このオブジェクトに対して `obj.name = 'hoge'` という操作を行ったとする\n#       2. `obj.name_changed?` は `true` を返すが、 `obj.desc_changed?` は `false` を返す\n#       3. 参考として、この時 `obj.changed?` は `true` を返す\n# 2. initializeメソッドはハッシュを受け取り、attr_accessorで作成したアトリビュートと同名のキーがあれば、自動でインスタンス変数に記録する\n#   1. ただし、この動作をwriterメソッドの履歴に残してはいけない\n# 3. 履歴がある場合、すべての操作履歴を放棄し、値も初期状態に戻す `restore!` メソッドを作成する\n\nmodule SimpleModel\nend",
    "answerCode": "# 問題の解説\n#\n# includeされたクラスのattr_accessorメソッドの挙動を変更するために、まずincludedフックメソッドを利用します。\n#\n# 初期値を管理する`_histories`と`_initial`属性をattr_accessorで用意しておきます。\n# historiesやinitialといった名前はクラスのメソッド定義などと衝突する可能性が高いので、`_`を先頭につけて回避するようにしています。\n# `_histories`は、writerメソッドを呼び出した時に、その値を記憶するためのハッシュです。キーは属性名、値はその属性に対する書き込み履歴の配列です。\n# `_initial`は、初期値を記憶するためのハッシュです。キーは属性名、値はその属性の初期値です。\n#\n# includedの中で対象のクラスをextendして、クラスメソッドであるattr_accessorメソッドを再定義します。\n# readerメソッドは通常通りの動作を行う、と仕様にあるのでattr_readerを呼び出しています。\n# writerメソッドは、通常に加え以下の動作を行うと仕様にあるので、独自に定義します。writerメソッドの中で、`_histories`に書き込み履歴を追記させています。\n# そのうえで、instance_variable_setで属性の値を書き換えています。\n#\n# initializeメソッドを定義し、`_initial`と`_histories`の初期化と`_initial`への初期値の記憶を行っています。\n# 残りの`restore`, `changed?`, `ATTR_changed?`メソッドは、`_initial`と`_histories`を活用することで問題なく実装できるはずです。\n#\nmodule SimpleModel\n  def self.included(klass)\n    klass.attr_accessor :_histories, :_initial\n    klass.extend(ClassMethods)\n  end\n\n  def initialize(args = {})\n    self._initial = args\n    self._histories = {}\n    args.each do |key, value|\n      instance_variable_set(\"@#{key}\", value)\n    end\n  end\n\n  def restore!\n    self._histories = {}\n    _initial.each do |key, value|\n      instance_variable_set(\"@#{key}\", value)\n    end\n  end\n\n  def changed?\n    !_histories.empty?\n  end\n\n  module ClassMethods\n    def attr_accessor(*syms)\n      syms.each { |sym| attr_reader sym }\n      syms.each do |sym|\n        define_method \"#{sym}=\" do |value|\n          (_histories[sym] ||= []).push(value)\n          instance_variable_set(\"@#{sym}\", value)\n        end\n\n        define_method \"#{sym}_changed?\" do\n          !!_histories[sym]\n        end\n      end\n    end\n  end\nend",
    "testCode": "require 'minitest'\n\nmodule SimpleModel\n  def self.included(klass)\n    klass.attr_accessor :_histories, :_initial\n    klass.extend(ClassMethods)\n  end\n\n  def initialize(args = {})\n    self._initial = args\n    self._histories = {}\n    args.each do |key, value|\n      instance_variable_set(\"@#{key}\", value)\n    end\n  end\n\n  def restore!\n    self._histories = {}\n    _initial.each do |key, value|\n      instance_variable_set(\"@#{key}\", value)\n    end\n  end\n\n  def changed?\n    !_histories.empty?\n  end\n\n  module ClassMethods\n    def attr_accessor(*syms)\n      syms.each { |sym| attr_reader sym }\n      syms.each do |sym|\n        define_method \"#{sym}=\" do |value|\n          (_histories[sym] ||= []).push(value)\n          instance_variable_set(\"@#{sym}\", value)\n        end\n\n        define_method \"#{sym}_changed?\" do\n          !!_histories[sym]\n        end\n      end\n    end\n  end\nend\n\nclass TestSimpleModel < Minitest::Test\n  class Product\n    include SimpleModel\n\n    attr_accessor :name, :description\n  end\n\n  def test_accessor\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    assert_equal 'SmarterHR', obj.name\n    assert_equal 'more smart SmartHR', obj.description\n  end\n\n  def test_writer\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = 'Ultra SmarterHR'\n    obj.description = 'more smart SmarterHR'\n    assert_equal 'Ultra SmarterHR', obj.name\n    assert_equal 'more smart SmarterHR', obj.description\n  end\n\n  def test_watching_not_changes_attrs\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    assert_equal false, obj.changed?\n  end\n\n  def test_watching_changes_attrs\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = 'SuperSmarterHR'\n    assert_equal true, obj.changed?\n  end\n\n  def test_watching_changes_each_attrs\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = 'SuperSmarterHR'\n    assert_equal true, obj.name_changed?\n    assert_equal false, obj.description_changed?\n  end\n\n  def test_restore_changes\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = 'Ultra SmarterHR'\n    obj.description = 'more smart SmarterHR'\n    obj.restore!\n    assert_equal 'SmarterHR', obj.name\n    assert_equal 'more smart SmartHR', obj.description\n    assert_equal false, obj.changed?\n  end\n\n  def test_random_read\n    name  = SecureRandom.hex\n    desc  = SecureRandom.hex\n    obj = Product.new(name: name, description: desc)\n    assert_equal name, obj.name\n    assert_equal desc, obj.description\n  end\n\n  def test_random_write\n    name  = SecureRandom.hex\n    desc  = SecureRandom.hex\n    obj = Product.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = name\n    obj.description = desc\n    assert_equal name, obj.name\n    assert_equal desc, obj.description\n  end\n\n  class MultipleAccessorsProduct\n    include SimpleModel\n\n    attr_accessor :name\n    attr_accessor :description\n  end\n\n  def test_multiple_accessors\n    obj = MultipleAccessorsProduct.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    assert_equal 'SmarterHR', obj.name\n    assert_equal 'more smart SmartHR', obj.description\n  end\n\n  def test_multiple_accessors_writer\n    obj = MultipleAccessorsProduct.new(name: 'SmarterHR', description: 'more smart SmartHR')\n    obj.name = 'Ultra SmarterHR'\n    obj.description = 'more smart SmarterHR'\n    assert_equal 'Ultra SmarterHR', obj.name\n    assert_equal 'more smart SmarterHR', obj.description\n  end\nend\n\n# 明示的にテストを実行するためのコード\ndef run_tests\n  parallel_executor = Object.new\n  def parallel_executor.shutdown\n    # nothing\n  end\n  Minitest.parallel_executor = parallel_executor\n  Minitest.run\nend"
  }
];
